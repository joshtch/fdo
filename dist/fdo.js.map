{"version":3,"file":"fdo.js","sources":["../src/constraint.js","../src/propagators/div.js","../src/markov.js","../src/propagators/markov.js","../src/propagators/min.js","../src/propagators/mul.js","../src/propagators/reified.js","../src/propagators/ring.js","../src/propagators/lt.js","../src/propagators/lte.js","../src/propagators/eq.js","../src/propagators/neq.js","../src/propagator.js","../src/config.js","../src/exporter.js","../src/importer.js","../src/space.js","../src/distribution/var.js","../src/distribution/markov.js","../src/distribution/value.js","../src/search.js","../src/fdo.js"],"sourcesContent":["// A constraint acts as a abstract model in Config from which\n// propagators are generated once a space is created. Constraints\n// tend to be more concise and reflect the original intent, whereas\n// propagators are low level. One constraint can generate multiple\n// propagators to do its work, like how sum(A,B,C) breaks down to\n// plus(plus(A,B), C) which in turn breaks down to 2x three propagators\n// for the plus.\n\nfunction constraint_create(name, varIndexes, param) {\n  return {\n    _class: '$constraint',\n    name,\n    varIndexes,\n    param,\n  };\n}\n\nexport { constraint_create };\n","import {\n  ASSERT,\n  ASSERT_LOG,\n  ASSERT_NORDOM,\n  LOG_FLAG_PROPSTEPS,\n  domain__debug,\n  domain_divby,\n  domain_intersection,\n} from 'fdlib';\n\n/**\n * @param {$space} space\n * @param {$config} config\n * @param {number} varIndex1\n * @param {number} varIndex2\n * @param {number} varIndex3\n * @returns {$fd_changeState}\n */\nfunction propagator_divStep(space, config, varIndex1, varIndex2, varIndex3) {\n  ASSERT(\n    varIndex1 >= 0 && varIndex2 >= 0 && varIndex3 >= 0,\n    'expecting three vars',\n    varIndex1,\n    varIndex2,\n    varIndex3\n  );\n  const domain1 = space.vardoms[varIndex1];\n  const domain2 = space.vardoms[varIndex2];\n  const domain3 = space.vardoms[varIndex3];\n\n  space.vardoms[varIndex3] = _propagator_divStep(domain1, domain2, domain3);\n\n  ASSERT_LOG(LOG_FLAG_PROPSTEPS, log =>\n    log(\n      'propagator_divStep; indexes:',\n      varIndex1,\n      varIndex2,\n      varIndex3,\n      'doms:',\n      domain__debug(domain1),\n      'div',\n      domain__debug(domain2),\n      'was',\n      domain__debug(domain3),\n      'now',\n      domain__debug(space.vardoms[varIndex3])\n    )\n  );\n  ASSERT_NORDOM(space.vardoms[varIndex1], true, domain__debug);\n  ASSERT_NORDOM(space.vardoms[varIndex2], true, domain__debug);\n  ASSERT_NORDOM(space.vardoms[varIndex3], true, domain__debug);\n}\n\n/**\n * @param {$nordom} domain1\n * @param {$nordom} domain2\n * @param {$nordom} domResult\n * @returns {$nordom}\n */\nfunction _propagator_divStep(domain1, domain2, domResult) {\n  ASSERT_NORDOM(domain1);\n  ASSERT_NORDOM(domain2);\n  ASSERT_NORDOM(domResult);\n  ASSERT(domain1 && domain2 && domResult, 'SHOULD_NOT_BE_REJECTED');\n\n  const domain = domain_divby(domain1, domain2);\n  return domain_intersection(domResult, domain);\n}\n\nexport { propagator_divStep };\n","// Markov helper functions\n\nimport { domain_getValue, domain_toList, THROW } from 'fdlib';\n\n/**\n * If a row has no boolean condition, return it.\n * If the boolean condition of a row is 1, return it.\n * If no row meets these conditions, return the last row.\n *\n * @param {$space} space\n * @param {?} matrix\n * @returns {*}\n */\nfunction markov_getNextRowToSolve(space, matrix) {\n  const { vardoms } = space;\n  let row;\n  for (let i = 0; i < matrix.length; i++) {\n    row = matrix[i];\n    const boolDomain = vardoms[row._boolVarIndex];\n    if (boolDomain === undefined || domain_getValue(boolDomain) === 1) {\n      break;\n    }\n  }\n\n  return row;\n}\n\nfunction markov_createLegend(merge, inputLegend, domain) {\n  if (merge) {\n    return markov_mergeDomainAndLegend(inputLegend, domain);\n  }\n\n  return inputLegend;\n}\n\nfunction markov_mergeDomainAndLegend(inputLegend, domain) {\n  let legend;\n  if (inputLegend) {\n    legend = inputLegend.slice(0);\n  } else {\n    legend = [];\n  }\n\n  const listed = domain_toList(domain);\n  for (let i = 0; i < listed.length; ++i) {\n    const val = listed[i];\n    if (legend.indexOf(val) < 0) {\n      legend.push(val);\n    }\n  }\n\n  return legend;\n}\n\nfunction markov_createProbVector(space, matrix, expandVectorsWith, valueCount) {\n  const row = markov_getNextRowToSolve(space, matrix);\n  let probVector = row.vector;\n\n  if (expandVectorsWith !== null) {\n    // Could be 0\n    probVector = probVector ? probVector.slice(0) : [];\n    const delta = valueCount - probVector.length;\n\n    if (delta > 0) {\n      for (let i = 0; i < delta; ++i) {\n        probVector.push(expandVectorsWith);\n      }\n    }\n\n    return probVector;\n  }\n\n  if (!probVector || probVector.length !== valueCount) {\n    THROW('E_EACH_MARKOV_VAR_MUST_HAVE_PROB_VECTOR_OR_ENABLE_EXPAND_VECTORS');\n  }\n\n  return probVector;\n}\n\nexport { markov_createLegend, markov_createProbVector };\n","import {\n  ASSERT,\n  ASSERT_LOG,\n  ASSERT_NORDOM,\n  LOG_FLAG_PROPSTEPS,\n  domain__debug,\n  domain_createEmpty,\n  domain_isSolved,\n  domain_min,\n} from 'fdlib';\n\nimport { markov_createLegend, markov_createProbVector } from '../markov';\n\n/**\n * Markov uses a special system for trying values. The domain doesn't\n * govern the list of possible values, only acts as a mask for the\n * current node in the search tree (-> space). But since FD will work\n * based on this domain anyways we will need this extra step to verify\n * whether a solved var is solved to a valid value in current context.\n *\n * Every markov variable should have a propagator. Perhaps later\n * there can be one markov propagator that checks all markov vars.\n *\n * @param {$space} space\n * @param {$config} config\n * @param {number} varIndex\n */\nfunction propagator_markovStepBare(space, config, varIndex) {\n  // THIS IS VERY EXPENSIVE IF expandVectorsWith IS ENABLED\n\n  ASSERT(typeof varIndex === 'number', 'VAR_INDEX_SHOULD_BE_NUMBER');\n\n  const domain = space.vardoms[varIndex];\n\n  ASSERT_NORDOM(domain);\n  ASSERT(domain, 'SHOULD_NOT_BE_REJECTED');\n\n  if (!domain_isSolved(domain)) {\n    ASSERT_LOG(LOG_FLAG_PROPSTEPS, log =>\n      log(\n        'propagator_markovStepBare; indexes:',\n        varIndex,\n        'was solved:',\n        domain__debug(domain)\n      )\n    );\n    return;\n  }\n\n  const value = domain_min(domain); // Note: solved so lo=hi=value\n\n  const configVarDistOptions = config.varDistOptions;\n  const distributeOptions = configVarDistOptions[config.allVarNames[varIndex]];\n\n  ASSERT(\n    distributeOptions,\n    'var should have a config',\n    varIndex,\n    distributeOptions && JSON.stringify(configVarDistOptions)\n  );\n  ASSERT(\n    distributeOptions.valtype === 'markov',\n    'var should be a markov var',\n    distributeOptions.valtype\n  );\n\n  const { expandVectorsWith } = distributeOptions;\n  ASSERT(\n    distributeOptions.matrix,\n    'there should be a matrix available for every var'\n  );\n  ASSERT(\n    distributeOptions.legend || expandVectorsWith !== null,\n    'every var should have a legend or expandVectorsWith set'\n  );\n\n  // Note: expandVectorsWith can be 0, so check with null\n  const values = markov_createLegend(\n    expandVectorsWith !== null,\n    distributeOptions.legend,\n    domain\n  ); // TODO: domain is a value, can this be optimized? is that worth the effort? (profile this)\n  const probabilities = markov_createProbVector(\n    space,\n    distributeOptions.matrix,\n    expandVectorsWith,\n    values.length\n  );\n\n  const pos = values.indexOf(value);\n  if (pos < 0 || pos >= probabilities.length || probabilities[pos] === 0) {\n    space.vardoms[varIndex] = domain_createEmpty();\n  }\n\n  ASSERT_LOG(LOG_FLAG_PROPSTEPS, log =>\n    log(\n      'propagator_markovStepBare; indexes:',\n      varIndex,\n      'was:',\n      domain__debug(domain),\n      'became:',\n      domain__debug(space.vardoms[varIndex])\n    )\n  );\n  ASSERT_NORDOM(space.vardoms[varIndex], true, domain__debug);\n}\n\nexport { propagator_markovStepBare };\n","import {\n  ASSERT,\n  ASSERT_LOG,\n  ASSERT_NORDOM,\n  LOG_FLAG_PROPSTEPS,\n  TRACE,\n  domain__debug,\n  domain_isEmpty,\n  domain_intersection,\n  domain_minus,\n} from 'fdlib';\n\n/**\n * Min as in minus. Only updates the result domain.\n *\n * @param {$space} space\n * @param {$config} config\n * @param {number} varIndex1\n * @param {number} varIndex2\n * @param {number} varIndex3\n */\nfunction propagator_minStep(space, config, varIndex1, varIndex2, varIndex3) {\n  ASSERT(\n    varIndex1 >= 0 && varIndex2 >= 0 && varIndex3 >= 0,\n    'expecting three vars',\n    varIndex1,\n    varIndex2,\n    varIndex3\n  );\n  const domain1 = space.vardoms[varIndex1];\n  const domain2 = space.vardoms[varIndex2];\n  const domain3 = space.vardoms[varIndex3];\n\n  // TODO: prune domain1 and domain2 like ring does, but here\n  const nR = _propagator_minStep(domain1, domain2, domain3);\n  space.vardoms[varIndex3] = nR;\n\n  ASSERT_LOG(LOG_FLAG_PROPSTEPS, log =>\n    log(\n      'propagator_minStep; indexes:',\n      varIndex1,\n      varIndex2,\n      varIndex3,\n      'doms:',\n      domain__debug(domain1),\n      domain__debug(domain2),\n      'was',\n      domain__debug(domain3),\n      'now',\n      domain__debug(space.vardoms[varIndex3])\n    )\n  );\n  ASSERT_NORDOM(space.vardoms[varIndex1], true, domain__debug);\n  ASSERT_NORDOM(space.vardoms[varIndex2], true, domain__debug);\n  ASSERT(\n    domain_isEmpty(nR) || (ASSERT_NORDOM(nR, true, domain__debug) || true),\n    'R can be empty'\n  );\n}\n\n/**\n * @param {$domain} domain1\n * @param {$domain} domain2\n * @param {$domain} domResult\n * @returns {$domain}\n */\nfunction _propagator_minStep(domain1, domain2, domResult) {\n  ASSERT_NORDOM(domain1);\n  ASSERT_NORDOM(domain2);\n  ASSERT(domain1 && domain2, 'SHOULD_NOT_BE_REJECTED');\n\n  const domain = domain_minus(domain1, domain2);\n  if (!domain) {\n    TRACE('_propagator_minStep resulted in empty domain');\n    return domain;\n  }\n\n  return domain_intersection(domResult, domain);\n}\n\nexport { propagator_minStep, _propagator_minStep };\n","import {\n  ASSERT,\n  ASSERT_LOG,\n  ASSERT_NORDOM,\n  LOG_FLAG_PROPSTEPS,\n  domain__debug,\n  domain_mul,\n  domain_intersection,\n} from 'fdlib';\n\n/**\n * @param {$space} space\n * @param {$config} config\n * @param {number} varIndex1\n * @param {number} varIndex2\n * @param {number} varIndex3\n */\nfunction propagator_mulStep(space, config, varIndex1, varIndex2, varIndex3) {\n  ASSERT(\n    varIndex1 >= 0 && varIndex2 >= 0 && varIndex3 >= 0,\n    'expecting three vars',\n    varIndex1,\n    varIndex2,\n    varIndex3\n  );\n  const { vardoms } = space;\n  const domain1 = vardoms[varIndex1];\n  const domain2 = vardoms[varIndex2];\n  const domain3 = vardoms[varIndex3];\n\n  space.vardoms[varIndex3] = _propagator_mulStep(domain1, domain2, domain3);\n\n  ASSERT_LOG(LOG_FLAG_PROPSTEPS, log =>\n    log(\n      'propagator_mulStep; indexes:',\n      varIndex1,\n      varIndex2,\n      varIndex3,\n      'doms:',\n      domain__debug(domain1),\n      'mul',\n      domain__debug(domain2),\n      'was',\n      domain__debug(domain3),\n      'now',\n      domain__debug(vardoms[varIndex3])\n    )\n  );\n  ASSERT_NORDOM(space.vardoms[varIndex1], true, domain__debug);\n  ASSERT_NORDOM(space.vardoms[varIndex2], true, domain__debug);\n  ASSERT_NORDOM(space.vardoms[varIndex3], true, domain__debug);\n}\n\n/**\n * @param {$domain} domain1\n * @param {$domain} domain2\n * @param {$domain} domResult\n * @returns {$domain}\n */\nfunction _propagator_mulStep(domain1, domain2, domResult) {\n  ASSERT_NORDOM(domain1);\n  ASSERT_NORDOM(domain2);\n  ASSERT(domain1 && domain2, 'SHOULD_NOT_BE_REJECTED');\n\n  const domain = domain_mul(domain1, domain2);\n\n  return domain_intersection(domResult, domain);\n}\n\nexport { propagator_mulStep };\n","import {\n  ASSERT,\n  ASSERT_LOG,\n  ASSERT_NORDOM,\n  LOG_FLAG_PROPSTEPS,\n  domain__debug,\n  domain_hasNoZero,\n  domain_isZero,\n  domain_removeGtUnsafe,\n  domain_removeValue,\n} from 'fdlib';\n\n/**\n * A boolean variable that represents whether a comparison\n * condition between two variables currently holds or not.\n *\n * @param {$space} space\n * @param {$config} config\n * @param {number} leftVarIndex\n * @param {number} rightVarIndex\n * @param {number} resultVarIndex\n * @param {Function} opFunc like propagator_ltStepBare\n * @param {Function} nopFunc opposite of opFunc like propagator_gtStepBare\n * @param {string} opName\n * @param {string} invOpName\n * @param {Function} opRejectChecker\n * @param {Function} nopRejectChecker\n */\nfunction propagator_reifiedStepBare(\n  space,\n  config,\n  leftVarIndex,\n  rightVarIndex,\n  resultVarIndex,\n  opFunc,\n  nopFunc,\n  opName,\n  invOpName,\n  opRejectChecker,\n  nopRejectChecker\n) {\n  ASSERT(space._class === '$space', 'SPACE_SHOULD_BE_SPACE');\n  ASSERT(typeof leftVarIndex === 'number', 'VAR_INDEX_SHOULD_BE_NUMBER');\n  ASSERT(typeof rightVarIndex === 'number', 'VAR_INDEX_SHOULD_BE_NUMBER');\n  ASSERT(typeof resultVarIndex === 'number', 'VAR_INDEX_SHOULD_BE_NUMBER');\n  ASSERT(typeof opName === 'string', 'OP_SHOULD_BE_STRING');\n  ASSERT(typeof invOpName === 'string', 'NOP_SHOULD_BE_STRING');\n\n  const { vardoms } = space;\n  const domResult = vardoms[resultVarIndex];\n\n  ASSERT_LOG(LOG_FLAG_PROPSTEPS, log =>\n    log(\n      'propagator_reifiedStepBare before; op:',\n      opName,\n      ', indexes:',\n      resultVarIndex,\n      '=',\n      leftVarIndex,\n      opName + '?',\n      rightVarIndex,\n      ', doms:',\n      domain__debug(vardoms[resultVarIndex]),\n      '=',\n      domain__debug(vardoms[leftVarIndex]),\n      opName + '?',\n      domain__debug(vardoms[rightVarIndex])\n    )\n  );\n\n  // The result var is either ZERO (reified constraint must not hold) or NONZERO (reified constraint must hold)\n  // the actual nonzero value, if any, is irrelevant\n\n  if (domain_isZero(domResult)) {\n    nopFunc(space, config, leftVarIndex, rightVarIndex);\n  } else if (domain_hasNoZero(domResult)) {\n    opFunc(space, config, leftVarIndex, rightVarIndex);\n  } else {\n    const domain1 = vardoms[leftVarIndex];\n    const domain2 = vardoms[rightVarIndex];\n\n    ASSERT_NORDOM(domain1);\n    ASSERT_NORDOM(domain2);\n    ASSERT(domain1 && domain2, 'SHOULD_NOT_BE_REJECTED');\n    ASSERT(\n      !domain_isZero(domResult) && !domain_hasNoZero(domResult),\n      'result should be booly now'\n    );\n\n    if (nopRejectChecker(domain1, domain2)) {\n      ASSERT(\n        !opRejectChecker(domain1, domain2),\n        'with non-empty domains op and nop cant BOTH reject'\n      );\n      vardoms[resultVarIndex] = domain_removeValue(domResult, 0);\n      opFunc(space, config, leftVarIndex, rightVarIndex);\n    } else if (opRejectChecker(domain1, domain2)) {\n      vardoms[resultVarIndex] = domain_removeGtUnsafe(domResult, 0);\n      nopFunc(space, config, leftVarIndex, rightVarIndex);\n    }\n  }\n\n  ASSERT_LOG(LOG_FLAG_PROPSTEPS, log =>\n    log(\n      'propagator_reifiedStepBare after; doms:',\n      domain__debug(vardoms[resultVarIndex]),\n      '=',\n      domain__debug(vardoms[leftVarIndex]),\n      opName + '?',\n      domain__debug(vardoms[rightVarIndex])\n    )\n  );\n  ASSERT_NORDOM(space.vardoms[leftVarIndex], true, domain__debug);\n  ASSERT_NORDOM(space.vardoms[rightVarIndex], true, domain__debug);\n  ASSERT_NORDOM(space.vardoms[resultVarIndex], true, domain__debug);\n}\n\nexport { propagator_reifiedStepBare };\n","import {\n  ASSERT,\n  ASSERT_LOG,\n  ASSERT_NORDOM,\n  LOG_FLAG_PROPSTEPS,\n  domain__debug,\n  domain_invMul,\n  domain_intersection,\n  domain_minus,\n  domain_mul,\n  domain_plus,\n} from 'fdlib';\n\n/**\n * @param {$space} space\n * @param {$config} config\n * @param {number} varIndex1\n * @param {number} varIndex2\n * @param {number} varIndex3\n * @param {string} opName\n * @param {Function} opFunc\n */\nfunction propagator_ringStepBare(\n  space,\n  config,\n  varIndex1,\n  varIndex2,\n  varIndex3,\n  opName,\n  opFunc\n) {\n  ASSERT(\n    varIndex1 >= 0 && varIndex2 >= 0 && varIndex3 >= 0,\n    'expecting three vars',\n    varIndex1,\n    varIndex2,\n    varIndex3\n  );\n  ASSERT(typeof opName === 'string', 'OP_SHOULD_BE_STRING');\n  const { vardoms } = space;\n  const domain1 = vardoms[varIndex1];\n  const domain2 = vardoms[varIndex2];\n  const domain3 = vardoms[varIndex3];\n\n  ASSERT(\n    (opName === 'plus' && opFunc === domain_plus) ||\n      (opName === 'min' && opFunc === domain_minus) ||\n      (opName === 'mul' && opFunc === domain_mul) ||\n      (opName === 'div' && opFunc === domain_invMul),\n    'should get proper opfunc'\n  );\n\n  space.vardoms[varIndex3] = _propagator_ringStepBare(\n    domain1,\n    domain2,\n    domain3,\n    opFunc,\n    opName\n  );\n\n  ASSERT_LOG(LOG_FLAG_PROPSTEPS, log =>\n    log(\n      'propagator_ringStepBare; op:',\n      opName,\n      'indexes:',\n      varIndex3,\n      '=',\n      varIndex1,\n      { u: '+', n: '-', l: '*', v: '/' }[opName[2]],\n      varIndex2,\n      ', names:',\n      config.allVarNames[varIndex3],\n      '=',\n      config.allVarNames[varIndex1],\n      { u: '+', n: '-', l: '*', v: '/' }[opName[2]],\n      config.allVarNames[varIndex2]\n    )\n  );\n  ASSERT_LOG(LOG_FLAG_PROPSTEPS, log =>\n    log(\n      ' - doms before:',\n      domain__debug(domain3),\n      '=',\n      domain__debug(domain1),\n      { u: '+', n: '-', l: '*', v: '/' }[opName[2]],\n      domain__debug(domain2)\n    )\n  );\n  ASSERT_LOG(LOG_FLAG_PROPSTEPS, log =>\n    log(\n      ' - doms after :',\n      domain__debug(vardoms[varIndex3]),\n      '=',\n      domain__debug(vardoms[varIndex1]),\n      { u: '+', n: '-', l: '*', v: '/' }[opName[2]],\n      domain__debug(vardoms[varIndex2])\n    )\n  );\n\n  ASSERT_NORDOM(space.vardoms[varIndex1], true, domain__debug);\n  ASSERT_NORDOM(space.vardoms[varIndex2], true, domain__debug);\n  ASSERT_NORDOM(space.vardoms[varIndex3], true, domain__debug);\n}\n\n/**\n * @param {$domain} domain1\n * @param {$domain} domain2\n * @param {$domain} domainResult\n * @param {Function} opFunc\n * @param {string} opName For debugging only, the canonical name of opFunc\n * @returns {$domain}\n */\nfunction _propagator_ringStepBare(\n  domain1,\n  domain2,\n  domainResult,\n  opFunc,\n  opName\n) {\n  ASSERT(typeof opFunc === 'function', 'EXPECTING_FUNC_TO_BE:', opName);\n  ASSERT_NORDOM(domain1);\n  ASSERT_NORDOM(domain2);\n  ASSERT(domain1 && domain2, 'SHOULD_NOT_BE_REJECTED');\n\n  const domain = opFunc(domain1, domain2);\n\n  return domain_intersection(domainResult, domain);\n}\n\nexport {\n  propagator_ringStepBare,\n  _propagator_ringStepBare, // Testing\n};\n","import {\n  ASSERT,\n  ASSERT_LOG,\n  ASSERT_NORDOM,\n  LOG_FLAG_PROPSTEPS,\n  domain__debug,\n  domain_max,\n  domain_min,\n  domain_removeGte,\n  domain_removeLte,\n} from 'fdlib';\n\n/**\n * @param {$space} space\n * @param {$config} config\n * @param {number} varIndex1\n * @param {number} varIndex2\n */\nfunction propagator_ltStepBare(space, config, varIndex1, varIndex2) {\n  ASSERT(space._class === '$space', 'SHOULD_GET_SPACE');\n  ASSERT(typeof varIndex1 === 'number', 'VAR_INDEX_SHOULD_BE_NUMBER');\n  ASSERT(typeof varIndex2 === 'number', 'VAR_INDEX_SHOULD_BE_NUMBER');\n\n  const domain1 = space.vardoms[varIndex1];\n  const domain2 = space.vardoms[varIndex2];\n\n  ASSERT_NORDOM(domain1);\n  ASSERT_NORDOM(domain2);\n  ASSERT(domain1 && domain2, 'SHOULD_NOT_BE_REJECTED');\n\n  const lo1 = domain_min(domain1);\n  const hi2 = domain_max(domain2);\n\n  space.vardoms[varIndex1] = domain_removeGte(domain1, hi2);\n  space.vardoms[varIndex2] = domain_removeLte(domain2, lo1);\n\n  ASSERT_LOG(LOG_FLAG_PROPSTEPS, log =>\n    log(\n      'propagator_ltStepBare; indexes:',\n      varIndex1,\n      varIndex2,\n      ', from:',\n      domain__debug(domain1),\n      '<',\n      domain__debug(domain2),\n      ', to:',\n      domain__debug(space.vardoms[varIndex1]),\n      '<',\n      domain__debug(space.vardoms[varIndex2])\n    )\n  );\n  ASSERT_NORDOM(space.vardoms[varIndex1], true, domain__debug);\n  ASSERT_NORDOM(space.vardoms[varIndex2], true, domain__debug);\n}\n\nfunction propagator_gtStepBare(space, config, varIndex1, varIndex2) {\n  return propagator_ltStepBare(space, config, varIndex2, varIndex1);\n}\n\n/**\n * Lt would reject if all elements in the left var are bigger or equal to\n * the right var. And since everything is CSIS, we only have to check the\n * lo bound of left to the high bound of right for that answer.\n * Read-only check\n *\n * @param {$domain} domain1\n * @param {$domain} domain2\n * @returns {boolean}\n */\nfunction propagator_ltStepWouldReject(domain1, domain2) {\n  ASSERT_NORDOM(domain1);\n  ASSERT_NORDOM(domain2);\n  ASSERT(domain1 && domain2, 'NON_EMPTY_DOMAIN_EXPECTED');\n\n  const result = domain_min(domain1) >= domain_max(domain2);\n  ASSERT_LOG(LOG_FLAG_PROPSTEPS, log =>\n    log(\n      'propagator_ltStepWouldReject;',\n      domain__debug(domain1),\n      '>=?',\n      domain__debug(domain2),\n      '=>',\n      domain_min(domain1),\n      '>=?',\n      domain_max(domain2),\n      '->',\n      result\n    )\n  );\n  return result;\n}\n\n/**\n * Reverse of propagator_ltStepWouldReject\n *\n * @param {$domain} domain1\n * @param {$domain} domain2\n * @returns {boolean}\n */\nfunction propagator_gtStepWouldReject(domain1, domain2) {\n  ASSERT_NORDOM(domain1);\n  ASSERT_NORDOM(domain2);\n  ASSERT(domain1 && domain2, 'NON_EMPTY_DOMAIN_EXPECTED');\n  return propagator_ltStepWouldReject(domain2, domain1);\n}\n\nexport {\n  propagator_gtStepBare,\n  propagator_gtStepWouldReject,\n  propagator_ltStepBare,\n  propagator_ltStepWouldReject,\n};\n","import {\n  ASSERT,\n  ASSERT_LOG,\n  ASSERT_NORDOM,\n  LOG_FLAG_PROPSTEPS,\n  domain__debug,\n  domain_max,\n  domain_min,\n  domain_removeGte,\n  domain_removeLte,\n} from 'fdlib';\n\n/**\n * @param {$space} space\n * @param {$config} config\n * @param {number} varIndex1\n * @param {number} varIndex2\n * @returns {$fd_changeState}\n */\nfunction propagator_lteStepBare(space, config, varIndex1, varIndex2) {\n  ASSERT(space._class === '$space', 'SHOULD_GET_SPACE');\n  ASSERT(typeof varIndex1 === 'number', 'VAR_INDEX_SHOULD_BE_NUMBER');\n  ASSERT(typeof varIndex2 === 'number', 'VAR_INDEX_SHOULD_BE_NUMBER');\n\n  const domain1 = space.vardoms[varIndex1];\n  const domain2 = space.vardoms[varIndex2];\n\n  ASSERT_NORDOM(domain1);\n  ASSERT_NORDOM(domain2);\n  ASSERT(domain1 && domain2, 'SHOULD_NOT_BE_REJECTED');\n\n  const lo1 = domain_min(domain1);\n  const hi2 = domain_max(domain2);\n\n  space.vardoms[varIndex1] = domain_removeGte(domain1, hi2 + 1);\n  space.vardoms[varIndex2] = domain_removeLte(domain2, lo1 - 1);\n\n  ASSERT_LOG(LOG_FLAG_PROPSTEPS, log =>\n    log(\n      'propagator_ltStepBare; indexes:',\n      varIndex1,\n      varIndex2,\n      ', from:',\n      domain__debug(domain1),\n      '<=',\n      domain__debug(domain2),\n      ', to:',\n      domain__debug(space.vardoms[varIndex1]),\n      '<=',\n      domain__debug(space.vardoms[varIndex2])\n    )\n  );\n  ASSERT_NORDOM(space.vardoms[varIndex1], true, domain__debug);\n  ASSERT_NORDOM(space.vardoms[varIndex2], true, domain__debug);\n}\n\nfunction propagator_gteStepBare(space, config, varIndex1, varIndex2) {\n  return propagator_lteStepBare(space, config, varIndex2, varIndex1);\n}\n\n/**\n * Lte would reject if all elements in the left var are bigger than the\n * right var. And since everything is CSIS, we only have to check the\n * lo bound of left to the high bound of right for that answer.\n *\n * @param {$domain} domain1\n * @param {$domain} domain2\n * @returns {boolean}\n */\nfunction propagator_lteStepWouldReject(domain1, domain2) {\n  ASSERT_NORDOM(domain1);\n  ASSERT_NORDOM(domain2);\n  ASSERT(domain1 && domain2, 'NON_EMPTY_DOMAIN_EXPECTED');\n\n  const result = domain_min(domain1) > domain_max(domain2);\n  ASSERT_LOG(LOG_FLAG_PROPSTEPS, log =>\n    log(\n      'propagator_lteStepWouldReject;',\n      domain__debug(domain1),\n      '>?',\n      domain__debug(domain2),\n      '=>',\n      domain_min(domain1),\n      '>?',\n      domain_max(domain2),\n      '->',\n      result\n    )\n  );\n  return result;\n}\n\n/**\n * Reverse of propagator_lteStepWouldReject\n *\n * @param {$domain} domain1\n * @param {$domain} domain2\n * @returns {boolean}\n */\nfunction propagator_gteStepWouldReject(domain1, domain2) {\n  return propagator_lteStepWouldReject(domain2, domain1);\n}\n\nexport {\n  propagator_gteStepBare,\n  propagator_gteStepWouldReject,\n  propagator_lteStepBare,\n  propagator_lteStepWouldReject,\n};\n","import {\n  ASSERT,\n  ASSERT_LOG,\n  ASSERT_NORDOM,\n  LOG_FLAG_PROPSTEPS,\n  domain__debug,\n  domain_intersection,\n  domain_sharesNoElements,\n} from 'fdlib';\n\n/**\n * This eq propagator looks a lot different from neq because in\n * eq we can prune early all values that are not covered by both.\n * Any value that is not covered by both can not be a valid solution\n * that holds this constraint. In neq that's different and we can\n * only start pruning once at least one var has a solution.\n * Basically eq is much more efficient compared to neq because we\n * can potentially skip a lot of values early.\n *\n * @param {$space} space\n * @param {$config} config\n * @param {number} varIndex1\n * @param {number} varIndex2\n * @returns {$fd_changeState}\n */\nfunction propagator_eqStepBare(space, config, varIndex1, varIndex2) {\n  ASSERT(space._class === '$space', 'SHOULD_GET_SPACE');\n  ASSERT(typeof varIndex1 === 'number', 'VAR_INDEX_SHOULD_BE_NUMBER');\n  ASSERT(typeof varIndex2 === 'number', 'VAR_INDEX_SHOULD_BE_NUMBER');\n\n  const { vardoms } = space;\n  const domain1 = vardoms[varIndex1];\n  const domain2 = vardoms[varIndex2];\n\n  ASSERT_NORDOM(domain1);\n  ASSERT_NORDOM(domain2);\n  ASSERT(domain1 && domain2, 'SHOULD_NOT_BE_REJECTED');\n\n  const result = domain_intersection(domain1, domain2);\n\n  vardoms[varIndex1] = result;\n  vardoms[varIndex2] = result;\n\n  ASSERT_LOG(LOG_FLAG_PROPSTEPS, log =>\n    log(\n      'propagator_eqStepBare; indexes:',\n      varIndex1,\n      varIndex2,\n      'doms:',\n      domain__debug(domain1),\n      'eq',\n      domain__debug(domain2),\n      '->',\n      domain__debug(result)\n    )\n  );\n  ASSERT_NORDOM(space.vardoms[varIndex1], true, domain__debug);\n  ASSERT_NORDOM(space.vardoms[varIndex2], true, domain__debug);\n}\n\n/**\n * The eq step would reject if there all elements in one domain\n * do not occur in the other domain. Because then there's no\n * valid option to make sure A=B holds. So search for such value\n * or return false.\n * Read only check\n *\n * @param {$domain} domain1\n * @param {$domain} domain2\n * @returns {boolean}\n */\nfunction propagator_eqStepWouldReject(domain1, domain2) {\n  ASSERT_NORDOM(domain1);\n  ASSERT_NORDOM(domain2);\n  ASSERT(domain1 && domain2, 'NON_EMPTY_DOMAIN_EXPECTED');\n\n  const result = domain_sharesNoElements(domain1, domain2);\n  ASSERT_LOG(LOG_FLAG_PROPSTEPS, log =>\n    log(\n      'propagator_eqStepWouldReject;',\n      domain__debug(domain1),\n      '!==',\n      domain__debug(domain2),\n      '->',\n      result\n    )\n  );\n  return result;\n}\n\nexport { propagator_eqStepBare, propagator_eqStepWouldReject };\n","import {\n  ASSERT,\n  ASSERT_LOG,\n  ASSERT_NORDOM,\n  LOG_FLAG_PROPSTEPS,\n  NO_SUCH_VALUE,\n  domain__debug,\n  domain_createEmpty,\n  domain_getValue,\n  domain_removeValue,\n} from 'fdlib';\n\n/**\n * @param {$space} space\n * @param {$config} config\n * @param {number} varIndex1\n * @param {number} varIndex2\n */\nfunction propagator_neqStepBare(space, config, varIndex1, varIndex2) {\n  ASSERT(space && space._class === '$space', 'SHOULD_GET_SPACE');\n  ASSERT(typeof varIndex1 === 'number', 'VAR_INDEX_SHOULD_BE_NUMBER');\n  ASSERT(typeof varIndex2 === 'number', 'VAR_INDEX_SHOULD_BE_NUMBER');\n\n  const { vardoms } = space;\n  const domain1 = vardoms[varIndex1];\n  const domain2 = vardoms[varIndex2];\n\n  ASSERT_NORDOM(domain1);\n  ASSERT_NORDOM(domain2);\n  ASSERT(domain1 && domain2, 'SHOULD_NOT_BE_REJECTED');\n\n  // Remove solved value from the other domain. confirm neither rejects over it.\n  let value = domain_getValue(domain1);\n  if (value === NO_SUCH_VALUE) {\n    // Domain1 is not solved, remove domain2 from domain1 if domain2 is solved\n    value = domain_getValue(domain2);\n    if (value !== NO_SUCH_VALUE) {\n      vardoms[varIndex1] = domain_removeValue(domain1, value);\n    }\n  } else if (domain1 === domain2) {\n    vardoms[varIndex1] = domain_createEmpty();\n    vardoms[varIndex2] = domain_createEmpty();\n  } else {\n    vardoms[varIndex2] = domain_removeValue(domain2, value);\n  }\n\n  ASSERT_LOG(LOG_FLAG_PROPSTEPS, log =>\n    log(\n      'propagator_neqStepBare; indexes:',\n      varIndex1,\n      varIndex2,\n      'doms:',\n      domain__debug(domain1),\n      'neq',\n      domain__debug(domain2),\n      '->',\n      domain__debug(vardoms[varIndex1]),\n      domain__debug(vardoms[varIndex2])\n    )\n  );\n  ASSERT_NORDOM(space.vardoms[varIndex1], true, domain__debug);\n  ASSERT_NORDOM(space.vardoms[varIndex2], true, domain__debug);\n}\n\n/**\n * Neq will only reject if both domains are solved and equal.\n * This is a read-only check.\n *\n * @param {$domain} domain1\n * @param {$domain} domain2\n * @returns {boolean}\n */\nfunction propagator_neqStepWouldReject(domain1, domain2) {\n  const value = domain_getValue(domain1);\n  const result = value !== NO_SUCH_VALUE && value === domain_getValue(domain2);\n  ASSERT_LOG(LOG_FLAG_PROPSTEPS, log =>\n    log(\n      'propagator_neqStepWouldReject;',\n      domain__debug(domain1),\n      '===',\n      domain__debug(domain2),\n      '->',\n      result\n    )\n  );\n  return result;\n}\n\nexport { propagator_neqStepBare, propagator_neqStepWouldReject };\n","import {\n  ASSERT,\n  domain_invMul,\n  domain_minus,\n  domain_mul,\n  domain_plus,\n  THROW,\n} from 'fdlib';\n\nimport { config_addPropagator, config_addVarAnonNothing } from './config';\n\nimport { propagator_divStep } from './propagators/div';\nimport { propagator_markovStepBare } from './propagators/markov';\nimport { propagator_minStep } from './propagators/min';\nimport { propagator_mulStep } from './propagators/mul';\nimport { propagator_reifiedStepBare } from './propagators/reified';\nimport { propagator_ringStepBare } from './propagators/ring';\n\nimport {\n  propagator_gtStepBare,\n  propagator_gtStepWouldReject,\n  propagator_ltStepBare,\n  propagator_ltStepWouldReject,\n} from './propagators/lt';\n\nimport {\n  propagator_gteStepBare,\n  propagator_gteStepWouldReject,\n  propagator_lteStepBare,\n  propagator_lteStepWouldReject,\n} from './propagators/lte';\n\nimport {\n  propagator_eqStepBare,\n  propagator_eqStepWouldReject,\n} from './propagators/eq';\n\nimport {\n  propagator_neqStepBare,\n  propagator_neqStepWouldReject,\n} from './propagators/neq';\n\n/**\n * @param {string} name\n * @param {Function} stepper\n * @param {number} index1\n * @param {number} [index2=-1]\n * @param {number} [index3=-1]\n * @param {string} [arg1='']\n * @param {string} [arg2='']\n * @param {string} [arg3='']\n * @param {string} [arg4='']\n * @param {string} [arg5='']\n * @param {string} [arg6='']\n * @returns {$propagator}\n */\nfunction propagator_create(\n  name,\n  stepper,\n  index1 = -1,\n  index2 = -1,\n  index3 = -1,\n  arg1 = '',\n  arg2 = '',\n  arg3 = '',\n  arg4 = '',\n  arg5 = '',\n  arg6 = ''\n) {\n  return {\n    _class: '$propagator',\n    name,\n    stepper,\n    index1,\n    index2,\n    index3,\n    arg1,\n    arg2,\n    arg3,\n    arg4,\n    arg5,\n    arg6,\n  };\n}\n\n/**\n * Adds propagators which reify the given operator application\n * to the given boolean variable.\n *\n * `opname` is a string giving the name of the comparison\n * operator to reify. Currently, 'eq', 'neq', 'lt', 'lte', 'gt' and 'gte'\n * are supported.\n *\n * `leftVarIndex` and `rightVarIndex` are the arguments accepted\n * by the comparison operator.\n *\n * `resultVarIndex` is the name of the boolean variable to which to\n * reify the comparison operator. Note that this boolean\n * variable must already have been declared. If this argument\n * is omitted from the call, then the `reified` function can\n * be used in \"functional style\" and will return the name of\n * the reified boolean variable which you can pass to other\n * propagator creator functions.\n *\n * @param {$config} config\n * @param {string} opname\n * @param {number} leftVarIndex\n * @param {number} rightVarIndex\n * @param {number} resultVarIndex\n */\nfunction propagator_addReified(\n  config,\n  opname,\n  leftVarIndex,\n  rightVarIndex,\n  resultVarIndex\n) {\n  ASSERT(config._class === '$config', 'EXPECTING_CONFIG');\n  ASSERT(typeof opname === 'string', 'OP_SHOULD_BE_STRING');\n  ASSERT(\n    typeof leftVarIndex === 'number' && leftVarIndex >= 0,\n    'LEFT_VAR_SHOULD_BE_VALID_INDEX',\n    leftVarIndex\n  );\n  ASSERT(\n    typeof rightVarIndex === 'number' && rightVarIndex >= 0,\n    'RIGHT_VAR_SHOULD_BE_VALID_INDEX',\n    rightVarIndex\n  );\n  ASSERT(\n    typeof resultVarIndex === 'number' && resultVarIndex >= 0,\n    'RESULT_VAR_SHOULD_BE_VALID_INDEX',\n    resultVarIndex\n  );\n\n  let nopName;\n  let opFunc;\n  let nopFunc;\n  let opRejectChecker;\n  let nopRejectChecker;\n  switch (opname) {\n    case 'eq': {\n      nopName = 'neq';\n      opFunc = propagator_eqStepBare;\n      nopFunc = propagator_neqStepBare;\n      opRejectChecker = propagator_eqStepWouldReject;\n      nopRejectChecker = propagator_neqStepWouldReject;\n      break;\n    }\n\n    case 'neq': {\n      nopName = 'eq';\n      opFunc = propagator_neqStepBare;\n      nopFunc = propagator_eqStepBare;\n      opRejectChecker = propagator_neqStepWouldReject;\n      nopRejectChecker = propagator_eqStepWouldReject;\n      break;\n    }\n\n    case 'lt':\n      opFunc = propagator_ltStepBare;\n      opRejectChecker = propagator_ltStepWouldReject;\n      nopName = 'gte';\n      nopFunc = propagator_gteStepBare;\n      nopRejectChecker = propagator_gteStepWouldReject;\n      break;\n\n    case 'lte':\n      opFunc = propagator_lteStepBare;\n      opRejectChecker = propagator_lteStepWouldReject;\n      nopName = 'gt';\n      nopFunc = propagator_gtStepBare;\n      nopRejectChecker = propagator_gtStepWouldReject;\n      break;\n\n    case 'gt':\n      return propagator_addReified(\n        config,\n        'lt',\n        rightVarIndex,\n        leftVarIndex,\n        resultVarIndex\n      );\n\n    case 'gte':\n      return propagator_addReified(\n        config,\n        'lte',\n        rightVarIndex,\n        leftVarIndex,\n        resultVarIndex\n      );\n\n    default:\n      THROW('UNKNOWN_REIFIED_OP');\n  }\n\n  config_addPropagator(\n    config,\n    propagator_create(\n      'reified',\n      propagator_reifiedStepBare,\n      leftVarIndex,\n      rightVarIndex,\n      resultVarIndex,\n      opFunc,\n      nopFunc,\n      opname,\n      nopName,\n      opRejectChecker,\n      nopRejectChecker\n    )\n  );\n}\n\n/**\n * Domain equality propagator. Creates the propagator\n * in given config.\n * Can pass in vars or numbers that become anonymous\n * vars. Must at least pass in one var because the\n * propagator would be useless otherwise.\n *\n * @param {$config} config\n * @param {number} leftVarIndex\n * @param {number} rightVarIndex\n */\nfunction propagator_addEq(config, leftVarIndex, rightVarIndex) {\n  ASSERT(config._class === '$config', 'EXPECTING_CONFIG');\n  ASSERT(\n    typeof leftVarIndex === 'number' && leftVarIndex >= 0,\n    'LEFT_VAR_SHOULD_BE_VALID_INDEX',\n    leftVarIndex\n  );\n  ASSERT(\n    typeof rightVarIndex === 'number' && rightVarIndex >= 0,\n    'RIGHT_VAR_SHOULD_BE_VALID_INDEX',\n    rightVarIndex\n  );\n\n  config_addPropagator(\n    config,\n    propagator_create('eq', propagator_eqStepBare, leftVarIndex, rightVarIndex)\n  );\n}\n\n/**\n * Less than propagator. See general propagator nores\n * for fdeq which also apply to this one.\n *\n * @param {$config} config\n * @param {number} leftVarIndex\n * @param {number} rightVarIndex\n */\nfunction propagator_addLt(config, leftVarIndex, rightVarIndex) {\n  ASSERT(config._class === '$config', 'EXPECTING_CONFIG');\n  ASSERT(\n    typeof leftVarIndex === 'number' && leftVarIndex >= 0,\n    'LEFT_VAR_SHOULD_BE_VALID_INDEX',\n    leftVarIndex\n  );\n  ASSERT(\n    typeof rightVarIndex === 'number' && rightVarIndex >= 0,\n    'RIGHT_VAR_SHOULD_BE_VALID_INDEX',\n    rightVarIndex\n  );\n\n  config_addPropagator(\n    config,\n    propagator_create('lt', propagator_ltStepBare, leftVarIndex, rightVarIndex)\n  );\n}\n\n/**\n * Greater than propagator.\n *\n * @param {$config} config\n * @param {number} leftVarIndex\n * @param {number} rightVarIndex\n */\nfunction propagator_addGt(config, leftVarIndex, rightVarIndex) {\n  // _swap_ v1 and v2 because: a>b is b<a\n  propagator_addLt(config, rightVarIndex, leftVarIndex);\n}\n\n/**\n * Less than or equal to propagator.\n *\n * @param {$config} config\n * @param {number} leftVarIndex\n * @param {number} rightVarIndex\n */\nfunction propagator_addLte(config, leftVarIndex, rightVarIndex) {\n  ASSERT(config._class === '$config', 'EXPECTING_CONFIG');\n  ASSERT(\n    typeof leftVarIndex === 'number' && leftVarIndex >= 0,\n    'LEFT_VAR_SHOULD_BE_VALID_INDEX',\n    leftVarIndex\n  );\n  ASSERT(\n    typeof rightVarIndex === 'number' && rightVarIndex >= 0,\n    'RIGHT_VAR_SHOULD_BE_VALID_INDEX',\n    rightVarIndex\n  );\n\n  config_addPropagator(\n    config,\n    propagator_create(\n      'lte',\n      propagator_lteStepBare,\n      leftVarIndex,\n      rightVarIndex\n    )\n  );\n}\n\n/**\n * @param {$config} config\n * @param {number} leftVarIndex\n * @param {number} rightVarIndex\n * @param {number} resultVarIndex\n */\nfunction propagator_addMul(\n  config,\n  leftVarIndex,\n  rightVarIndex,\n  resultVarIndex\n) {\n  ASSERT(config._class === '$config', 'EXPECTING_CONFIG');\n  ASSERT(\n    typeof leftVarIndex === 'number' && leftVarIndex >= 0,\n    'LEFT_VAR_SHOULD_BE_VALID_INDEX',\n    leftVarIndex\n  );\n  ASSERT(\n    typeof rightVarIndex === 'number' && rightVarIndex >= 0,\n    'RIGHT_VAR_SHOULD_BE_VALID_INDEX',\n    rightVarIndex\n  );\n  ASSERT(\n    typeof resultVarIndex === 'number' && resultVarIndex >= 0,\n    'RESULT_VAR_SHOULD_BE_VALID_INDEX',\n    resultVarIndex\n  );\n\n  config_addPropagator(\n    config,\n    propagator_create(\n      'mul',\n      propagator_mulStep,\n      leftVarIndex,\n      rightVarIndex,\n      resultVarIndex\n    )\n  );\n}\n\n/**\n * @param {$config} config\n * @param {number} leftVarIndex\n * @param {number} rightVarIndex\n * @param {number} resultVarIndex\n */\nfunction propagator_addDiv(\n  config,\n  leftVarIndex,\n  rightVarIndex,\n  resultVarIndex\n) {\n  ASSERT(config._class === '$config', 'EXPECTING_CONFIG');\n  ASSERT(\n    typeof leftVarIndex === 'number' && leftVarIndex >= 0,\n    'LEFT_VAR_SHOULD_BE_VALID_INDEX',\n    leftVarIndex\n  );\n  ASSERT(\n    typeof rightVarIndex === 'number' && rightVarIndex >= 0,\n    'RIGHT_VAR_SHOULD_BE_VALID_INDEX',\n    rightVarIndex\n  );\n  ASSERT(\n    typeof resultVarIndex === 'number' && resultVarIndex >= 0,\n    'RESULT_VAR_SHOULD_BE_VALID_INDEX',\n    resultVarIndex\n  );\n\n  config_addPropagator(\n    config,\n    propagator_create(\n      'div',\n      propagator_divStep,\n      leftVarIndex,\n      rightVarIndex,\n      resultVarIndex\n    )\n  );\n}\n\n/**\n * Greater than or equal to.\n *\n * @param {$config} config\n * @param {number} leftVarIndex\n * @param {number} rightVarIndex\n */\nfunction propagator_addGte(config, leftVarIndex, rightVarIndex) {\n  // _swap_ v1 and v2 because: a>=b is b<=a\n  propagator_addLte(config, rightVarIndex, leftVarIndex);\n}\n\n/**\n * Ensures that the two variables take on different values.\n *\n * @param {$config} config\n * @param {number} leftVarIndex\n * @param {number} rightVarIndex\n */\nfunction propagator_addNeq(config, leftVarIndex, rightVarIndex) {\n  ASSERT(config._class === '$config', 'EXPECTING_CONFIG');\n  ASSERT(\n    typeof leftVarIndex === 'number' && leftVarIndex >= 0,\n    'LEFT_VAR_SHOULD_BE_VALID_INDEX',\n    leftVarIndex\n  );\n  ASSERT(\n    typeof rightVarIndex === 'number' && rightVarIndex >= 0,\n    'RIGHT_VAR_SHOULD_BE_VALID_INDEX',\n    rightVarIndex\n  );\n\n  config_addPropagator(\n    config,\n    propagator_create(\n      'neq',\n      propagator_neqStepBare,\n      leftVarIndex,\n      rightVarIndex\n    )\n  );\n}\n\n/**\n * Takes an arbitrary number of FD variables and adds propagators that\n * ensure that they are pairwise distinct.\n *\n * @param {$config} config\n * @param {number[]} varIndexes\n */\nfunction propagator_addDistinct(config, varIndexes) {\n  ASSERT(config._class === '$config', 'EXPECTING_CONFIG');\n\n  for (let i = 0; i < varIndexes.length; i++) {\n    const varIndex = varIndexes[i];\n    for (let j = 0; j < i; ++j) {\n      propagator_addNeq(config, varIndex, varIndexes[j]);\n    }\n  }\n}\n\n/**\n * @param {$config} config\n * @param {string} targetOpName\n * @param {string} invOpName\n * @param {Function} opFunc\n * @param {Function} nopFunc\n * @param {number} leftVarIndex\n * @param {number} rightVarIndex\n * @param {number} resultVarIndex\n */\nfunction propagator_addRingPlusOrMul(\n  config,\n  targetOpName,\n  invOpName,\n  opFunc,\n  nopFunc,\n  leftVarIndex,\n  rightVarIndex,\n  resultVarIndex\n) {\n  ASSERT(config._class === '$config', 'EXPECTING_CONFIG');\n  ASSERT(typeof targetOpName === 'string', 'OP_SHOULD_BE_STRING');\n  ASSERT(typeof invOpName === 'string', 'INV_OP_SHOULD_BE_STRING');\n  ASSERT(\n    typeof leftVarIndex === 'number' && leftVarIndex >= 0,\n    'LEFT_VAR_SHOULD_BE_VALID_INDEX',\n    leftVarIndex\n  );\n  ASSERT(\n    typeof rightVarIndex === 'number' && rightVarIndex >= 0,\n    'RIGHT_VAR_SHOULD_BE_VALID_INDEX',\n    rightVarIndex\n  );\n  ASSERT(\n    typeof resultVarIndex === 'number' && resultVarIndex >= 0,\n    'RESULT_VAR_SHOULD_BE_VALID_INDEX',\n    resultVarIndex\n  );\n\n  propagator_addRing(\n    config,\n    leftVarIndex,\n    rightVarIndex,\n    resultVarIndex,\n    targetOpName,\n    opFunc\n  );\n  propagator_addRing(\n    config,\n    resultVarIndex,\n    rightVarIndex,\n    leftVarIndex,\n    invOpName,\n    nopFunc\n  );\n  propagator_addRing(\n    config,\n    resultVarIndex,\n    leftVarIndex,\n    rightVarIndex,\n    invOpName,\n    nopFunc\n  );\n}\n\n/**\n * @param {$config} config\n * @param {string} A\n * @param {string} B\n * @param {string} C\n * @param {string} opName\n * @param {Function} opFunc\n */\nfunction propagator_addRing(config, A, B, C, opName, opFunc) {\n  ASSERT(config._class === '$config', 'EXPECTING_CONFIG');\n  ASSERT(typeof A === 'number' && A >= 0, 'LEFT_VAR_SHOULD_BE_VALID_INDEX', A);\n  ASSERT(typeof B === 'number' && B >= 0, 'RIGHT_VAR_SHOULD_BE_VALID_INDEX', B);\n  ASSERT(\n    typeof C === 'number' && C >= 0,\n    'RESULT_VAR_SHOULD_BE_VALID_INDEX',\n    C\n  );\n\n  config_addPropagator(\n    config,\n    propagator_create('ring', propagator_ringStepBare, A, B, C, opName, opFunc)\n  );\n}\n\n/**\n * Bidirectional addition propagator.\n *\n * @param {$config} config\n * @param {number} leftVarIndex\n * @param {number} rightVarIndex\n * @param {number} resultVarIndex\n */\nfunction propagator_addPlus(\n  config,\n  leftVarIndex,\n  rightVarIndex,\n  resultVarIndex\n) {\n  propagator_addRingPlusOrMul(\n    config,\n    'plus',\n    'min',\n    domain_plus,\n    domain_minus,\n    leftVarIndex,\n    rightVarIndex,\n    resultVarIndex\n  );\n}\n\n/**\n * @param {$config} config\n * @param {number} leftVarIndex\n * @param {number} rightVarIndex\n * @param {number} resultVarIndex\n */\nfunction propagator_addMin(\n  config,\n  leftVarIndex,\n  rightVarIndex,\n  resultVarIndex\n) {\n  ASSERT(config._class === '$config', 'EXPECTING_CONFIG');\n  ASSERT(\n    typeof leftVarIndex === 'number' && leftVarIndex >= 0,\n    'LEFT_VAR_SHOULD_BE_VALID_INDEX',\n    leftVarIndex\n  );\n  ASSERT(\n    typeof rightVarIndex === 'number' && rightVarIndex >= 0,\n    'RIGHT_VAR_SHOULD_BE_VALID_INDEX',\n    rightVarIndex\n  );\n  ASSERT(\n    typeof resultVarIndex === 'number' && resultVarIndex >= 0,\n    'RESULT_VAR_SHOULD_BE_VALID_INDEX',\n    resultVarIndex\n  );\n\n  config_addPropagator(\n    config,\n    propagator_create(\n      'min',\n      propagator_minStep,\n      leftVarIndex,\n      rightVarIndex,\n      resultVarIndex\n    )\n  );\n}\n\n/**\n * Bidirectional multiplication propagator.\n *\n * @param {$config} config\n * @param {number} leftVarIndex\n * @param {number} rightVarIndex\n * @param {number} resultVarIndex\n */\nfunction propagator_addRingMul(\n  config,\n  leftVarIndex,\n  rightVarIndex,\n  resultVarIndex\n) {\n  propagator_addRingPlusOrMul(\n    config,\n    'mul',\n    'div',\n    domain_mul,\n    domain_invMul,\n    leftVarIndex,\n    rightVarIndex,\n    resultVarIndex\n  );\n}\n\n/**\n * Sum of N domains = resultVar\n * Creates as many anonymous varIndexes as necessary.\n *\n * @param {$config} config\n * @param {number[]} varIndexes\n * @param {number} resultVarIndex\n */\nfunction propagator_addSum(config, varIndexes, resultVarIndex) {\n  ASSERT(config._class === '$config', 'EXPECTING_CONFIG');\n  ASSERT(\n    Array.isArray(varIndexes),\n    'varIndexes should be an array of var names',\n    varIndexes\n  );\n  ASSERT(\n    typeof resultVarIndex === 'number' && resultVarIndex >= 0,\n    'RESULT_VAR_SHOULD_BE_VALID_INDEX',\n    typeof resultVarIndex,\n    resultVarIndex\n  );\n\n  const len = varIndexes.length;\n  switch (len) {\n    case 0:\n      THROW('SUM_REQUIRES_VARS');\n      return undefined;\n\n    case 1:\n      propagator_addEq(config, resultVarIndex, varIndexes[0]);\n      return undefined;\n\n    case 2:\n      propagator_addPlus(config, varIndexes[0], varIndexes[1], resultVarIndex);\n      return undefined;\n\n    default:\n      break;\n  }\n\n  // \"divide and conquer\" ugh. feels like there is a better way to do this\n  ASSERT(len > 2, 'expecting at least 3 elements in the list...', varIndexes);\n\n  let t1;\n  const n = Math.floor(varIndexes.length / 2);\n  if (n > 1) {\n    t1 = config_addVarAnonNothing(config);\n    propagator_addSum(config, varIndexes.slice(0, n), t1);\n  } else {\n    t1 = varIndexes[0];\n  }\n\n  const t2 = config_addVarAnonNothing(config);\n  propagator_addSum(config, varIndexes.slice(n), t2);\n  propagator_addPlus(config, t1, t2, resultVarIndex);\n}\n\n/**\n * Product of N varIndexes = resultVar.\n * Create as many anonymous varIndexes as necessary.\n *\n * @param {$config} config\n * @param {number[]} varIndexes\n * @param {number} resultVarIndex\n */\nfunction propagator_addProduct(config, varIndexes, resultVarIndex) {\n  ASSERT(config._class === '$config', 'EXPECTING_CONFIG');\n  ASSERT(\n    Array.isArray(varIndexes),\n    'varIndexes should be an array of var names',\n    varIndexes\n  );\n  ASSERT(\n    typeof resultVarIndex === 'number' && resultVarIndex >= 0,\n    'RESULT_VAR_SHOULD_BE_VALID_INDEX',\n    resultVarIndex\n  );\n\n  switch (varIndexes.length) {\n    case 0:\n      THROW('PRODUCT_REQUIRES_VARS');\n      return undefined;\n\n    case 1:\n      // Note: by putting the result var first we get\n      // the var name back for it in case it's a number\n      propagator_addEq(config, resultVarIndex, varIndexes[0]);\n      return undefined;\n\n    case 2:\n      propagator_addRingMul(\n        config,\n        varIndexes[0],\n        varIndexes[1],\n        resultVarIndex\n      );\n      return undefined;\n\n    default:\n      break;\n  }\n\n  const n = Math.floor(varIndexes.length / 2);\n  let t1;\n  if (n > 1) {\n    t1 = config_addVarAnonNothing(config);\n    propagator_addProduct(config, varIndexes.slice(0, n), t1);\n  } else {\n    t1 = varIndexes[0];\n  }\n\n  const t2 = config_addVarAnonNothing(config);\n  propagator_addProduct(config, varIndexes.slice(n), t2);\n  propagator_addRingMul(config, t1, t2, resultVarIndex);\n}\n\n/**\n * @param {$config} config\n * @param {number} varIndex\n */\nfunction propagator_addMarkov(config, varIndex) {\n  ASSERT(config._class === '$config', 'EXPECTING_CONFIG');\n  ASSERT(\n    typeof varIndex === 'number' && varIndex >= 0,\n    'VAR_SHOULD_BE_VALID_INDEX',\n    varIndex\n  );\n\n  config_addPropagator(\n    config,\n    propagator_create('markov', propagator_markovStepBare, varIndex)\n  );\n}\n\nexport {\n  propagator_addDistinct,\n  propagator_addDiv,\n  propagator_addEq,\n  propagator_addGt,\n  propagator_addGte,\n  propagator_addLt,\n  propagator_addLte,\n  propagator_addMarkov,\n  propagator_addMin,\n  propagator_addMul,\n  propagator_addNeq,\n  propagator_addPlus,\n  propagator_addProduct,\n  propagator_addReified,\n  propagator_addRingMul,\n  propagator_addSum,\n  // For testing\n  propagator_addRing,\n  propagator_addRingPlusOrMul,\n};\n","// Config for a search tree where each node is a Space\n// TOFIX: may want to rename this to \"tree-state\" or something; it's not just config\n\n// Note: all domains in this class should be array based!\n// This prevents leaking the small domain artifact outside of the library.\n\nimport {\n  ASSERT,\n  ASSERT_NORDOM,\n  ASSERT_VARDOMS_SLOW,\n  NOT_FOUND,\n  SUB,\n  SUP,\n  domain__debug,\n  domain_createRange,\n  domain_getValue,\n  domain_max,\n  domain_min,\n  domain_isSolved,\n  domain_toSmallest,\n  domain_anyToSmallest,\n  INSPECT,\n  THROW,\n  getTerm,\n  TRIE_KEY_NOT_FOUND,\n  trie_add,\n  trie_create,\n  trie_get,\n  trie_has,\n} from 'fdlib';\n\nimport { constraint_create } from './constraint';\n\nimport { distribution_getDefaults } from './distribution/defaults';\n\nimport {\n  propagator_addDistinct,\n  propagator_addDiv,\n  propagator_addEq,\n  propagator_addGt,\n  propagator_addGte,\n  propagator_addLt,\n  propagator_addLte,\n  propagator_addMarkov,\n  propagator_addMul,\n  propagator_addNeq,\n  propagator_addPlus,\n  propagator_addMin,\n  propagator_addProduct,\n  propagator_addReified,\n  propagator_addRingMul,\n  propagator_addSum,\n} from './propagator';\n\n/**\n * @returns {$config}\n */\nfunction config_create() {\n  const config = {\n    _class: '$config',\n    // Names of all vars in this search tree\n    allVarNames: [],\n    // Doing `indexOf` for 5000+ names is _not_ fast. so use a trie\n    _varNamesTrie: trie_create(),\n\n    varStratConfig: config_createVarStratConfig(),\n    valueStratName: 'min',\n    targetedVars: 'all',\n    varDistOptions: {},\n    beforeSpace: undefined,\n    afterSpace: undefined,\n\n    // This is for the rng stuff in this library. in due time all calls\n    // should happen through this function. and it should be initialized\n    // with the rngCode string for exportability. this would be required\n    // for webworkers and DSL imports which can't have functions. tests\n    // can initialize it to something static, prod can use a seeded rng.\n    rngCode: '', // String. Function(rngCode) should return a callable rng\n    _defaultRng: undefined, // Function. if not exist at init time it'll be `rngCode ? Function(rngCode) : Math.random`\n\n    // the propagators are generated from the constraints when a space\n    // is created from this config. constraints are more higher level.\n    allConstraints: [],\n\n    constantCache: {}, // <value:varIndex>, generally anonymous vars but pretty much first come first serve\n    initialDomains: [], // $nordom[] : initial domains for each var, maps 1:1 to allVarNames\n\n    _propagators: [], // Initialized later\n    _varToPropagators: [], // Initialized later\n    _constrainedAway: [], // List of var names that were constrained but whose constraint was optimized away. they will still be \"targeted\" if target is all. TODO: fix all tests that depend on this and eliminate this. it is a hack.\n\n    _constraintHash: {}, // Every constraint is logged here (note: for results only the actual constraints are stored). if it has a result, the value is the result var _name_. otherwise just `true` if it exists and `false` if it was optimized away.\n  };\n\n  if (process.env.NODE_ENV !== 'production') {\n    config._propagates = 0;\n  }\n\n  return config;\n}\n\nfunction config_clone(config, newDomains) {\n  ASSERT(config._class === '$config', 'EXPECTING_CONFIG');\n\n  const {\n    varStratConfig,\n    valueStratName,\n    targetedVars,\n    varDistOptions,\n    constantCache,\n    allVarNames,\n    allConstraints,\n    initialDomains,\n    _propagators,\n    _varToPropagators,\n    _constrainedAway,\n  } = config;\n\n  const clone = {\n    _class: '$config',\n    _varNamesTrie: trie_create(allVarNames), // Just create a new trie with (should be) the same names\n\n    varStratConfig,\n    valueStratName,\n    targetedVars: Array.isArray(targetedVars)\n      ? targetedVars.slice(0)\n      : targetedVars,\n    varDistOptions: JSON.parse(JSON.stringify(varDistOptions)), // TOFIX: clone this more efficiently\n\n    rngCode: config.rngCode,\n    _defaultRng: config.rngCode ? undefined : config._defaultRng,\n\n    constantCache, // Is by reference ok?\n\n    allVarNames: allVarNames.slice(0),\n    allConstraints: allConstraints.slice(0),\n    initialDomains: newDomains\n      ? newDomains.map(domain_toSmallest)\n      : initialDomains, // <varName:domain>\n\n    _propagators: _propagators && _propagators.slice(0), // In case it is initialized\n    _varToPropagators: _varToPropagators && _varToPropagators.slice(0), // Inited elsewhere\n    _constrainedAway: _constrainedAway && _constrainedAway.slice(0), // List of var names that were constrained but whose constraint was optimized away. they will still be \"targeted\" if target is all. TODO: fix all tests that depend on this and eliminate this. it is a hack.\n\n    // not sure what to do with this in the clone...\n    _constraintHash: {},\n  };\n\n  if (process.env.NODE_ENV !== 'production') {\n    clone._propagates = 0;\n  }\n\n  return clone;\n}\n\n/**\n * Add an anonymous var with max allowed range\n *\n * @param {$config} config\n * @returns {number} varIndex\n */\nfunction config_addVarAnonNothing(config) {\n  return config_addVarNothing(config, true);\n}\n\n/**\n * @param {$config} config\n * @param {string|boolean} varName (If true, is anonymous)\n * @returns {number} varIndex\n */\nfunction config_addVarNothing(config, varName) {\n  return _config_addVar(config, varName, domain_createRange(SUB, SUP));\n}\n\n/**\n * @param {$config} config\n * @param {number} lo\n * @param {number} hi\n * @returns {number} varIndex\n */\nfunction config_addVarAnonRange(config, lo, hi) {\n  ASSERT(config._class === '$config', 'EXPECTING_CONFIG');\n  ASSERT(typeof lo === 'number', 'A_LO_MUST_BE_NUMBER');\n  ASSERT(typeof hi === 'number', 'A_HI_MUST_BE_NUMBER');\n\n  if (lo === hi) return config_addVarAnonConstant(config, lo);\n\n  return config_addVarRange(config, true, lo, hi);\n}\n\n/**\n * @param {$config} config\n * @param {string|boolean} varName (If true, is anonymous)\n * @param {number} lo\n * @param {number} hi\n * @returns {number} varIndex\n */\nfunction config_addVarRange(config, varName, lo, hi) {\n  ASSERT(config._class === '$config', 'EXPECTING_CONFIG');\n  ASSERT(\n    typeof varName === 'string' || varName === true,\n    'A_VARNAME_SHOULD_BE_STRING_OR_TRUE'\n  );\n  ASSERT(typeof lo === 'number', 'A_LO_MUST_BE_NUMBER');\n  ASSERT(typeof hi === 'number', 'A_HI_MUST_BE_NUMBER');\n  ASSERT(lo <= hi, 'A_RANGES_SHOULD_ASCEND');\n\n  const domain = domain_createRange(lo, hi);\n  return _config_addVar(config, varName, domain);\n}\n\n/**\n * @param {$config} config\n * @param {string|boolean} varName (If true, anon)\n * @param {$arrdom} domain Small domain format not allowed here. this func is intended to be called from FDO, which only accepts arrdoms\n * @returns {number} varIndex\n */\nfunction config_addVarDomain(config, varName, domain, _allowEmpty, _override) {\n  ASSERT(Array.isArray(domain), 'DOMAIN_MUST_BE_ARRAY_HERE');\n\n  return _config_addVar(\n    config,\n    varName,\n    domain_anyToSmallest(domain),\n    _allowEmpty,\n    _override\n  );\n}\n\n/**\n * @param {$config} config\n * @param {number} value\n * @returns {number} varIndex\n */\nfunction config_addVarAnonConstant(config, value) {\n  ASSERT(config._class === '$config', 'EXPECTING_CONFIG');\n  ASSERT(typeof value === 'number', 'A_VALUE_SHOULD_BE_NUMBER');\n\n  if (config.constantCache[value] !== undefined) {\n    return config.constantCache[value];\n  }\n\n  return config_addVarConstant(config, true, value);\n}\n\n/**\n * @param {$config} config\n * @param {string|boolean} varName (True means anon)\n * @param {number} value\n * @returns {number} varIndex\n */\nfunction config_addVarConstant(config, varName, value) {\n  ASSERT(config._class === '$config', 'EXPECTING_CONFIG');\n  ASSERT(\n    typeof varName === 'string' || varName === true,\n    'varName must be a string or true for anon'\n  );\n  ASSERT(typeof value === 'number', 'A_VALUE_SHOULD_BE_NUMBER');\n\n  const domain = domain_createRange(value, value);\n\n  return _config_addVar(config, varName, domain);\n}\n\n/**\n * @param {$config} config\n * @param {string|true} varName If true, the varname will be the same as the index it gets on allVarNames\n * @param {$nordom} domain\n * @returns {number} varIndex\n */\nfunction _config_addVar(\n  config,\n  varName,\n  domain,\n  _allowEmpty,\n  _override = false\n) {\n  ASSERT(config._class === '$config', 'EXPECTING_CONFIG');\n  ASSERT(_allowEmpty || domain, 'NON_EMPTY_DOMAIN');\n  ASSERT(\n    _allowEmpty || domain_min(domain) >= SUB,\n    'domain lo should be >= SUB',\n    domain\n  );\n  ASSERT(\n    _allowEmpty || domain_max(domain) <= SUP,\n    'domain hi should be <= SUP',\n    domain\n  );\n\n  if (_override) {\n    ASSERT(\n      trie_has(config._varNamesTrie, varName),\n      'Assuming var exists when explicitly overriding'\n    );\n    const index = trie_get(config._varNamesTrie, varName);\n    ASSERT(index >= 0, 'should exist');\n    ASSERT_NORDOM(domain, true, domain__debug);\n    config.initialDomains[index] = domain;\n    return;\n  }\n\n  const { allVarNames } = config;\n  const varIndex = allVarNames.length;\n\n  if (varName === true) {\n    varName = '__' + String(varIndex) + '__';\n  } else {\n    if (typeof varName !== 'string')\n      THROW(\n        'Var names should be a string or anonymous, was: ' +\n          JSON.stringify(varName)\n      );\n    if (!varName) THROW('Var name cannot be empty string');\n    if (String(parseInt(varName, 10)) === varName)\n      THROW(\"Don't use numbers as var names (\" + varName + ')');\n  }\n\n  // Note: 100 is an arbitrary number but since large sets are probably\n  // automated it's very unlikely we'll need this check in those cases\n  if (varIndex < 100) {\n    if (trie_has(config._varNamesTrie, varName))\n      THROW('Var name already part of this config. Probably a bug?', varName);\n  }\n\n  const solvedTo = domain_getValue(domain);\n  if (solvedTo !== NOT_FOUND && !config.constantCache[solvedTo])\n    config.constantCache[solvedTo] = varIndex;\n\n  ASSERT_NORDOM(domain, true, domain__debug);\n  config.initialDomains[varIndex] = domain;\n  config.allVarNames.push(varName);\n  trie_add(config._varNamesTrie, varName, varIndex);\n\n  return varIndex;\n}\n\n/**\n * Initialize the config of this space according to certain presets\n *\n * @param {$config} config\n * @param {string} varName\n */\nfunction config_setDefaults(config, varName) {\n  ASSERT(config._class === '$config', 'EXPECTING_CONFIG');\n  const defs = distribution_getDefaults(varName);\n  for (const [key, def] of Object.entries(defs)) {\n    config_setOption(config, key, def);\n  }\n}\n\n/**\n * Create a config object for the var distribution\n *\n * @param {Object} obj\n * @property {string} [obj.type] Map to the internal names for var distribution strategies\n * @property {string} [obj.priorityByName] An ordered list of var names to prioritize. Names not in the list go implicitly and unordered last.\n * @property {boolean} [obj.inverted] Should the list be interpreted inverted? Unmentioned names still go last, regardless.\n * @property {Object} [obj.fallback] Same struct as obj. If current strategy is inconclusive it can fallback to another strategy.\n * @returns {$var_strat_config}\n */\nfunction config_createVarStratConfig(obj) {\n  /**\n   * @typedef {$var_strat_config}\n   */\n  return {\n    _class: '$var_strat_config',\n    type: (obj && obj.type) || 'naive',\n    priorityByName: obj && obj.priorityByName,\n    _priorityByIndex: undefined,\n    inverted: Boolean(obj && obj.inverted),\n    fallback: obj && obj.fallback,\n  };\n}\n\n/**\n * Configure an option for the solver\n *\n * @param {$config} config\n * @param {string} optionName\n * @param {*} optionValue\n * @param {string} [optionTarget] For certain options, this is the target var name\n */\nfunction config_setOption(config, optionName, optionValue, optionTarget) {\n  ASSERT(config._class === '$config', 'EXPECTING_CONFIG');\n  ASSERT(typeof optionName === 'string', 'option name is a string');\n  ASSERT(optionValue !== undefined, 'should get a value');\n  ASSERT(\n    optionTarget === undefined || typeof optionTarget === 'string',\n    'the optional name is a string'\n  );\n\n  if (optionName === 'varStratOverride') {\n    THROW('deprecated, should be wiped internally');\n  }\n\n  let fallback = false;\n  switch (optionName) {\n    case 'varStrategyFallback':\n      fallback = true;\n    // Fall-through\n    case 'varStrategy': {\n      if (typeof optionValue === 'function')\n        THROW('functions no longer supported', optionValue);\n      if (typeof optionValue === 'string')\n        THROW('strings should be passed on as {type:value}', optionValue);\n      if (typeof optionValue !== 'object')\n        THROW('varStrategy should be object', optionValue);\n      if (optionValue.name) THROW('name should be type');\n      if (optionValue.dist_name) THROW('dist_name should be type');\n      ASSERT(\n        !optionTarget,\n        'optionTarget is not used for varStrategy (this is not \"per-var strat\")'\n      );\n      let vsc = config_createVarStratConfig(optionValue);\n      if (fallback) {\n        let rvsc = config.varStratConfig;\n        ASSERT(rvsc, 'there must be an existing config to add a fallback');\n        while (rvsc.fallback) rvsc = rvsc.fallback;\n        rvsc.fallback = vsc;\n      } else {\n        config.varStratConfig = vsc;\n        while (vsc.fallback) {\n          vsc.fallback = config_createVarStratConfig(vsc.fallback);\n          vsc = vsc.fallback;\n        }\n      }\n\n      break;\n    }\n\n    case 'valueStrategy':\n      // Determine how the next value of a variable is picked when creating a new space\n      config.valueStratName = optionValue;\n      break;\n\n    case 'targeted_var_names':\n      if (!optionValue || optionValue.length === 0) {\n        THROW('ONLY_USE_WITH_SOME_TARGET_VARS'); // Omit otherwise to target all\n      }\n\n      // Which vars must be solved for this space to be solved\n      // string: 'all'\n      // string[]: list of vars that must be solved\n      // function: callback to return list of names to be solved\n      config.targetedVars = optionValue;\n      break;\n\n    case 'varStratOverrides':\n      // An object which defines a value distributor per variable\n      // which overrides the globally set value distributor.\n      // See Bvar#distributeOptions (in multiverse)\n\n      for (const [key, value] of Object.entries(optionValue)) {\n        config_setOption(config, 'varValueStrat', value, key);\n      }\n\n      break;\n\n    case 'varValueStrat':\n      // Override all the specific strategy parameters for one variable\n      ASSERT(typeof optionTarget === 'string', 'expecting a name');\n      if (!config.varDistOptions) config.varDistOptions = {};\n      ASSERT(!config.varDistOptions[optionTarget], 'should not be known yet');\n      config.varDistOptions[optionTarget] = optionValue;\n\n      if (optionValue.valtype === 'markov') {\n        let { matrix } = optionValue;\n        if (!matrix) {\n          if (optionValue.expandVectorsWith) {\n            optionValue.matrix = [{ vector: [] }];\n            matrix = optionValue.matrix;\n          } else {\n            THROW(\n              'FDO: markov var missing distribution (needs matrix or expandVectorsWith)'\n            );\n          }\n        }\n\n        for (const row of matrix) {\n          if (row.boolean)\n            THROW('row.boolean was deprecated in favor of row.boolVarName');\n          if (row.booleanId !== undefined)\n            THROW(\n              'row.booleanId is no longer used, please use row.boolVarName'\n            );\n          let boolFuncOrName = row.boolVarName;\n          if (typeof boolFuncOrName === 'function') {\n            boolFuncOrName = boolFuncOrName(optionValue);\n          }\n\n          if (boolFuncOrName) {\n            if (typeof boolFuncOrName !== 'string') {\n              THROW(\n                'row.boolVarName, if it exists, should be the name of a var or a func that returns that name, was/got: ' +\n                  boolFuncOrName +\n                  ' (' +\n                  typeof boolFuncOrName +\n                  ')'\n              );\n            }\n\n            // Store the var index\n            row._boolVarIndex = trie_get(config._varNamesTrie, boolFuncOrName);\n          }\n        }\n      }\n\n      break;\n\n    // Hooks called before and after propagating each space.\n    // The callback receives the targeted Space object.\n    // If it returns truthy it immediately aborts the search entirely.\n    // (Can be used for timeout, inspection, or manual selection)\n    case 'beforeSpace':\n      config.beforeSpace = optionValue;\n      break;\n    case 'afterSpace':\n      config.afterSpace = optionValue;\n      break;\n\n    case 'var':\n      return THROW('REMOVED. Replace `var` with `varStrategy`');\n    case 'val':\n      return THROW('REMOVED. Replace `var` with `valueStrategy`');\n\n    case 'rng':\n      // Sets the default rng for this solve. a string should be raw js\n      // code, number will be a static return value, a function is used\n      // as is. the resulting function should return a value `0<=v<1`\n      if (typeof optionValue === 'string') {\n        config.rngCode = optionValue;\n      } else if (typeof optionValue === 'number') {\n        config.rngCode = 'return ' + optionValue + ';'; // Dont use arrow function. i dont think this passes through babel.\n      } else {\n        ASSERT(\n          typeof optionValue === 'function',\n          'rng should be a preferably a string and otherwise a function'\n        );\n        config._defaultRng = optionValue;\n      }\n\n      break;\n\n    default:\n      THROW('unknown option');\n  }\n}\n\n/**\n * This function should be removed once we can update mv\n *\n * @deprecated in favor of config_setOption\n * @param {$config} config\n * @param {Object} options\n * @property {Object} [options.varStrategy]\n * @property {string} [options.varStrategy.name]\n * @property {string[]} [options.varStrategy.list] Only if name=list\n * @property {string[]} [options.varStrategy.priorityByName] Only if name=list\n * @property {boolean} [options.varStrategy.inverted] Only if name=list\n * @property {Object} [options.varStrategy.fallback] Same struct as options.varStrategy (recursive)\n * @property {Function} [options.beforeSpace] To be called before each Space propagation\n * @property {Function} [options.afterSpace] To be called after each Space propagation\n */\nfunction config_setOptions(config, options) {\n  if (!options) return;\n\n  if (options.varStrategy)\n    config_setOption(config, 'varStrategy', options.varStrategy);\n  if (options.valueStrategy)\n    config_setOption(config, 'valueStrategy', options.valueStrategy);\n  if (options.targeted_var_names)\n    config_setOption(config, 'targeted_var_names', options.targeted_var_names);\n  if (options.varStratOverrides)\n    config_setOption(config, 'varStratOverrides', options.varStratOverrides);\n  if (options.varStratOverride) {\n    getTerm().warn('deprecated \"varStratOverride\" in favor of \"varValueStrat\"');\n    config_setOption(\n      config,\n      'varValueStrat',\n      options.varStratOverride,\n      options.varStratOverrideName\n    );\n  }\n\n  if (options.varValueStrat)\n    config_setOption(\n      config,\n      'varValueStrat',\n      options.varValueStrat,\n      options.varStratOverrideName\n    );\n  if (options.beforeSpace)\n    config_setOption(config, 'beforeSpace', options.beforeSpace);\n  if (options.afterSpace)\n    config_setOption(config, 'afterSpace', options.afterSpace);\n}\n\n/**\n * @param {$config} config\n * @param {$propagator} propagator\n */\nfunction config_addPropagator(config, propagator) {\n  ASSERT(config._class === '$config', 'EXPECTING_CONFIG');\n  ASSERT(propagator._class === '$propagator', 'EXPECTING_PROPAGATOR');\n  config._propagators.push(propagator);\n}\n\n/**\n * Creates a mapping from a varIndex to a set of propagatorIndexes\n * These propagators are the ones that use the varIndex\n * This is useful for quickly determining which propagators\n * need to be stepped while propagating them.\n *\n * @param {$config} config\n */\nfunction config_populateVarPropHash(config) {\n  const hash = new Array(config.allVarNames.length);\n  const propagators = config._propagators;\n  const { initialDomains } = config;\n  for (\n    let propagatorIndex = 0, plen = propagators.length;\n    propagatorIndex < plen;\n    ++propagatorIndex\n  ) {\n    const propagator = propagators[propagatorIndex];\n    _config_addVarConditionally(\n      propagator.index1,\n      initialDomains,\n      hash,\n      propagatorIndex\n    );\n    if (propagator.index2 >= 0)\n      _config_addVarConditionally(\n        propagator.index2,\n        initialDomains,\n        hash,\n        propagatorIndex\n      );\n    if (propagator.index3 >= 0)\n      _config_addVarConditionally(\n        propagator.index3,\n        initialDomains,\n        hash,\n        propagatorIndex\n      );\n  }\n\n  config._varToPropagators = hash;\n}\n\nfunction _config_addVarConditionally(\n  varIndex,\n  initialDomains,\n  hash,\n  propagatorIndex\n) {\n  // (at some point this could be a strings, or array, or whatever)\n  ASSERT(typeof varIndex === 'number', 'must be number');\n  // Dont bother adding props on unsolved vars because they can't affect\n  // anything anymore. seems to prevent about 10% in our case so worth it.\n  const domain = initialDomains[varIndex];\n  ASSERT_NORDOM(domain, true, domain__debug);\n  if (!domain_isSolved(domain)) {\n    if (!hash[varIndex]) hash[varIndex] = [propagatorIndex];\n    else if (hash[varIndex].indexOf(propagatorIndex) < 0)\n      hash[varIndex].push(propagatorIndex);\n  }\n}\n\n/**\n * Create a constraint. If the constraint has a result var it\n * will return (only) the variable name that ends up being\n * used (anonymous or not).\n *\n * In some edge cases the constraint can be resolved immediately.\n * There are two ways a constraint can resolve: solved or reject.\n * A solved constraint is omitted and if there is a result var it\n * will become a constant that is set to the outcome of the\n * constraint. If rejected the constraint will still be added and\n * will immediately reject the search once it starts.\n *\n * Due to constant optimization and mapping the result var name\n * may differ from the input var name. In that case both names\n * should map to the same var index internally. Only constraints\n * with a result var have a return value here.\n *\n * @param {$config} config\n * @param {string} name Type of constraint (hardcoded values)\n * @param {<string,number,undefined>[]} varNames All the argument var names for target constraint\n * @param {string} [param] The result var name for certain. With reifiers param is the actual constraint to reflect.\n * @returns {string|undefined} Actual result vars only, undefined otherwise. See desc above.\n */\nfunction config_addConstraint(config, name, varNames, param) {\n  // Should return a new var name for most props\n  ASSERT(config && config._class === '$config', 'EXPECTING_CONFIG');\n  ASSERT(\n    varNames.every(\n      e => typeof e === 'string' || typeof e === 'number' || e === undefined\n    ),\n    'all var names should be strings or numbers or undefined',\n    varNames\n  );\n\n  let inputConstraintKeyOp = name;\n  let resultVarName;\n\n  let anonIsBool = false;\n  switch (name /* eslint no-fallthrough: \"off\" */) {\n    case 'reifier':\n      anonIsBool = true;\n      inputConstraintKeyOp = param;\n    // Fall-through\n    case 'plus':\n    case 'min':\n    case 'ring-mul':\n    case 'ring-div':\n    case 'mul':\n      ASSERT(varNames.length === 3, 'MISSING_RESULT_VAR'); // Note that the third value may still be \"undefined\"\n    // fall-through\n    case 'sum':\n    case 'product': {\n      const sumOrProduct = name === 'product' || name === 'sum';\n\n      resultVarName = sumOrProduct ? param : varNames[2];\n      let resultVarIndex;\n\n      if (resultVarName === undefined) {\n        if (anonIsBool) resultVarIndex = config_addVarAnonRange(config, 0, 1);\n        else resultVarIndex = config_addVarAnonNothing(config);\n        resultVarName = config.allVarNames[resultVarIndex];\n      } else if (typeof resultVarName === 'number') {\n        resultVarIndex = config_addVarAnonConstant(config, resultVarName);\n        resultVarName = config.allVarNames[resultVarIndex];\n      } else if (typeof resultVarName === 'string') {\n        resultVarIndex = trie_get(config._varNamesTrie, resultVarName);\n        if (resultVarIndex < 0)\n          THROW(\n            'Vars must be defined before using them (' + resultVarName + ')'\n          );\n      } else {\n        THROW(\n          `expecting result var name to be absent or a number or string: \\`${resultVarName}\\``\n        );\n      }\n\n      if (sumOrProduct) param = resultVarIndex;\n      else varNames[2] = resultVarName;\n\n      break;\n    }\n\n    case 'distinct':\n    case 'eq':\n    case 'neq':\n    case 'lt':\n    case 'lte':\n    case 'gt':\n    case 'gte':\n      break;\n\n    default:\n      THROW(`UNKNOWN_PROPAGATOR ${name}`);\n  }\n\n  // Note: if param is a var constant then that case is already resolved above\n  config_compileConstants(config, varNames);\n\n  if (\n    config_dedupeConstraint(\n      config,\n      inputConstraintKeyOp + '|' + varNames.join(','),\n      resultVarName\n    )\n  )\n    return resultVarName;\n\n  const varIndexes = config_varNamesToIndexes(config, varNames);\n\n  const constraint = constraint_create(name, varIndexes, param);\n  config.allConstraints.push(constraint);\n\n  return resultVarName;\n}\n\n/**\n * Go through the list of var names and create an anonymous var for\n * each value that is actually a number rather than a string.\n * Replaces the values inline.\n *\n * @param {$config} config\n * @param {string|number} varNames\n */\nfunction config_compileConstants(config, varNames) {\n  for (let i = 0, n = varNames.length; i < n; ++i) {\n    if (typeof varNames[i] === 'number') {\n      const varIndex = config_addVarAnonConstant(config, varNames[i]);\n      varNames[i] = config.allVarNames[varIndex];\n    }\n  }\n}\n\n/**\n * Convert a list of var names to a list of their indexes\n *\n * @param {$config} config\n * @param {string[]} varNames\n * @returns {number[]}\n */\nfunction config_varNamesToIndexes(config, varNames) {\n  const varIndexes = [];\n  for (let i = 0, n = varNames.length; i < n; ++i) {\n    const varName = varNames[i];\n    ASSERT(\n      typeof varName === 'string',\n      'var names should be strings here',\n      varName,\n      i,\n      varNames\n    );\n    const varIndex = trie_get(config._varNamesTrie, varName);\n    if (varIndex === TRIE_KEY_NOT_FOUND)\n      THROW(\n        'CONSTRAINT_VARS_SHOULD_BE_DECLARED',\n        'name=',\n        varName,\n        'index=',\n        i,\n        'names=',\n        varNames\n      );\n    varIndexes[i] = varIndex;\n  }\n\n  return varIndexes;\n}\n\n/**\n * Check whether we already know a given constraint (represented by a unique string).\n * If we don't, add the string to the cache with the expected result name, if any.\n *\n * @param config\n * @param constraintUI\n * @param resultVarName\n * @returns {boolean}\n */\nfunction config_dedupeConstraint(config, constraintUI, resultVarName) {\n  if (!config._constraintHash) config._constraintHash = {}; // Can happen for imported configs that are extended or smt\n  const haveConstraint = config._constraintHash[constraintUI];\n\n  if (haveConstraint === true) {\n    if (resultVarName !== undefined) {\n      throw new Error('How is this possible?'); // Either a constraint-with-value gets a result var, or it's a constraint-sans-value\n    }\n\n    return true;\n  }\n\n  if (haveConstraint !== undefined) {\n    ASSERT(\n      typeof haveConstraint === 'string',\n      'if not true or undefined, it should be a string'\n    );\n    ASSERT(\n      resultVarName && typeof resultVarName === 'string',\n      'if it was recorded as a constraint-with-value then it should have a result var now as well'\n    );\n    // The constraint exists and had a result. map that result to this result for equivalent results.\n    config_addConstraint(config, 'eq', [resultVarName, haveConstraint]); // _could_ also be optimized away ;)\n    return true;\n  }\n\n  config._constraintHash[constraintUI] = resultVarName || true;\n  return false;\n}\n\n/**\n * Generate all propagators from the constraints in given config\n * Puts these back into the same config.\n *\n * @param {$config} config\n */\nfunction config_generatePropagators(config) {\n  ASSERT(config && config._class === '$config', 'EXPECTING_CONFIG');\n  const { allConstraints } = config;\n  config._propagators = [];\n  for (const constraint of allConstraints) {\n    if (constraint.varNames) {\n      getTerm().warn(\n        'saw constraint.varNames, converting to varIndexes, log out result and update test accordingly'\n      );\n      constraint.varIndexes = constraint.varNames.map(name =>\n        trie_get(config._varNamesTrie, name)\n      );\n      const p = constraint.param;\n      delete constraint.param;\n      delete constraint.varNames;\n      constraint.param = p;\n    }\n\n    if (constraint.varIndexes[1] === -1)\n      throw new Error('nope? ' + INSPECT(constraint));\n\n    config_generatePropagator(\n      config,\n      constraint.name,\n      constraint.varIndexes,\n      constraint.param,\n      constraint\n    );\n  }\n}\n\n/**\n * @param {$config} config\n * @param {string} name\n * @param {number[]} varIndexes\n * @param {string|undefined} param Depends on the prop; reifier=op name, product/sum=result var\n */\nfunction config_generatePropagator(\n  config,\n  name,\n  varIndexes,\n  param,\n  _constraint\n) {\n  ASSERT(config && config._class === '$config', 'EXPECTING_CONFIG');\n  ASSERT(typeof name === 'string', 'NAME_SHOULD_BE_STRING');\n  ASSERT(\n    Array.isArray(varIndexes),\n    'INDEXES_SHOULD_BE_ARRAY',\n    JSON.stringify(_constraint)\n  );\n\n  switch (name) {\n    case 'plus':\n      return propagator_addPlus(\n        config,\n        varIndexes[0],\n        varIndexes[1],\n        varIndexes[2]\n      );\n\n    case 'min':\n      return propagator_addMin(\n        config,\n        varIndexes[0],\n        varIndexes[1],\n        varIndexes[2]\n      );\n\n    case 'ring-mul':\n      return propagator_addRingMul(\n        config,\n        varIndexes[0],\n        varIndexes[1],\n        varIndexes[2]\n      );\n\n    case 'ring-div':\n      return propagator_addDiv(\n        config,\n        varIndexes[0],\n        varIndexes[1],\n        varIndexes[2]\n      );\n\n    case 'mul':\n      return propagator_addMul(\n        config,\n        varIndexes[0],\n        varIndexes[1],\n        varIndexes[2]\n      );\n\n    case 'sum':\n      return propagator_addSum(config, varIndexes.slice(0), param);\n\n    case 'product':\n      return propagator_addProduct(config, varIndexes.slice(0), param);\n\n    case 'distinct':\n      return propagator_addDistinct(config, varIndexes.slice(0));\n\n    case 'reifier':\n      return propagator_addReified(\n        config,\n        param,\n        varIndexes[0],\n        varIndexes[1],\n        varIndexes[2]\n      );\n\n    case 'neq':\n      return propagator_addNeq(config, varIndexes[0], varIndexes[1]);\n\n    case 'eq':\n      return propagator_addEq(config, varIndexes[0], varIndexes[1]);\n\n    case 'gte':\n      return propagator_addGte(config, varIndexes[0], varIndexes[1]);\n\n    case 'lte':\n      return propagator_addLte(config, varIndexes[0], varIndexes[1]);\n\n    case 'gt':\n      return propagator_addGt(config, varIndexes[0], varIndexes[1]);\n\n    case 'lt':\n      return propagator_addLt(config, varIndexes[0], varIndexes[1]);\n\n    default:\n      THROW('UNEXPECTED_NAME: ' + name);\n  }\n}\n\nfunction config_generateMarkovs(config) {\n  const { varDistOptions } = config;\n  for (const varName of Object.keys(varDistOptions)) {\n    const varIndex = trie_get(config._varNamesTrie, varName);\n    if (varIndex < 0)\n      THROW(\n        'Found markov var options for an unknown var name (name=' +\n          varName +\n          ')'\n      );\n    const options = varDistOptions[varName];\n    if (options && options.valtype === 'markov') {\n      return propagator_addMarkov(config, varIndex);\n    }\n  }\n}\n\nfunction config_populateVarStrategyListHash(config) {\n  let vsc = config.varStratConfig;\n  while (vsc) {\n    if (vsc.priorityByName) {\n      const obj = {};\n      const list = vsc.priorityByName;\n      for (let i = 0, len = list.length; i < len; ++i) {\n        const varIndex = trie_get(config._varNamesTrie, list[i]);\n        ASSERT(\n          varIndex !== TRIE_KEY_NOT_FOUND,\n          'VARS_IN_PRIO_LIST_SHOULD_BE_KNOWN_NOW'\n        );\n        obj[varIndex] = len - i; // Never 0, offset at 1. higher value is higher prio\n      }\n\n      vsc._priorityByIndex = obj;\n    }\n\n    vsc = vsc.fallback;\n  }\n}\n\n/**\n * At the start of a search, populate this config with the dynamic data\n *\n * @param {$config} config\n */\nfunction config_init(config) {\n  ASSERT(config._class === '$config', 'EXPECTING_CONFIG');\n  if (!config._varNamesTrie) {\n    config._varNamesTrie = trie_create(config.allVarNames);\n  }\n\n  // Generate the default rng (\"Random Number Generator\") to use in stuff like markov\n  // We prefer the rngCode because that way we can serialize the config (required for stuff like webworkers)\n  if (!config._defaultRng)\n    config._defaultRng = config.rngCode\n      ? new Function(config.rngCode)\n      : Math.random; /* eslint no-new-func: \"off\" */\n\n  ASSERT_VARDOMS_SLOW(config.initialDomains, domain__debug);\n  config_generatePropagators(config);\n  config_generateMarkovs(config);\n  config_populateVarPropHash(config);\n  config_populateVarStrategyListHash(config);\n  ASSERT_VARDOMS_SLOW(config.initialDomains, domain__debug);\n\n  ASSERT(config._varToPropagators, 'should have generated hash');\n}\n\nexport {\n  config_addConstraint,\n  config_addPropagator,\n  config_addVarAnonConstant,\n  config_addVarAnonNothing,\n  config_addVarAnonRange,\n  config_addVarConstant,\n  config_addVarDomain,\n  config_addVarNothing,\n  config_addVarRange,\n  config_clone,\n  config_create,\n  config_createVarStratConfig,\n  config_generatePropagators,\n  config_init,\n  config_populateVarPropHash,\n  config_setDefaults,\n  config_setOption,\n  config_setOptions,\n  // Testing\n  _config_addVar,\n};\n","// This is an export function for config\n// it converts a $config to a DSL string\n// see /docs/dsl.txt for syntax\n// see importer.js to parse this DSL\n\nimport { THROW, getTerm, domain_getValue, domain_toArr, trie_get } from 'fdlib';\n\n/**\n * Export a given config with optional target domains\n * (initial domains otherwise) to special DSL string.\n * The resulting string should be usable with the\n * importer to create a new solver with same state.\n * This function only omits constraints when they only\n * consist of constants. Optimization should occur elsewhere.\n *\n * @param {$config} config\n * @param {$domain[]} [vardoms] If not given then config.initialDomains are used\n * @param {boolean} [usePropagators] Output the low-level propagators instead of the higher level constraints\n * @param {boolean} [minimal] Omit comments, use short var names, reduce whitespace where possible. etc\n * @param {boolean} [withDomainComments] Put the input domains behind each constraint even if minimal=true\n * @param {boolean} [realName] Use the original var names?\n * @returns {string}\n */\nfunction exporter(\n  config,\n  vardoms,\n  usePropagators,\n  minimal,\n  withDomainComments,\n  realName\n) {\n  // TOFIX: the alias stuff needs to be unique. currently exports from presolver clash with names generated here.\n  realName = true;\n  // TODO: dont export contants that are not bound to constraints and not targeted explicitly\n  // TODO: deal export->import better wrt anonymous vars\n  const var_dist_options = config.varDistOptions;\n  const domains = vardoms || config.initialDomains;\n  const varNames = config.allVarNames;\n\n  const indexToString = realName\n    ? index => exporter_encodeVarName(varNames[index])\n    : minimal\n    ? exporter_varstrShort\n    : exporter_varstrNum;\n\n  const vars = varNames.map((varName, varIndex) => {\n    const domain = exporter_domstr(domains[varIndex]);\n    let s = ': ' + indexToString(varIndex) + ' = ' + domain;\n    const overrides = var_dist_options[varName];\n    if (\n      overrides &&\n      (overrides.valtype !== 'list' ||\n        (overrides.list && overrides.list.length > 0))\n    ) {\n      s += ' @' + overrides.valtype;\n      switch (overrides.valtype) {\n        case 'markov':\n          if ('expandVectorsWith' in overrides)\n            s += 'expand(' + (overrides.expandVectorsWith || 0) + ')';\n          if ('legend' in overrides)\n            s += ' legend(' + overrides.legend.join(' ') + ')';\n          if ('matrix' in overrides)\n            s +=\n              ' matrix(' +\n              JSON.stringify(overrides.matrix).replace(/\"/g, '') +\n              ')';\n          break;\n\n        case 'list':\n          if (typeof overrides.list === 'function') s += ' prio(???func???)';\n          else s += ' prio(' + overrides.list.join(' ') + ')';\n          break;\n\n        case 'max':\n        case 'mid':\n        case 'min':\n        case 'minMaxCycle':\n        case 'naive':\n        case 'splitMax':\n        case 'splitMin':\n          break;\n\n        default:\n          getTerm().warn(\n            'Unknown value strategy override: ' + overrides.valtype\n          );\n          s += ' @? ' + JSON.stringify(overrides);\n      }\n    }\n\n    if (!realName && varName !== String(varIndex))\n      s += String(' # ' + exporter_encodeVarName(varName));\n    return s;\n  });\n\n  const constraints = usePropagators\n    ? []\n    : config.allConstraints\n        .map(constraint => {\n          const indexes = constraint.varIndexes;\n\n          // Create var names for each index, unless solved, in that case use solved value as literal\n          const aliases = indexes.map(indexToString);\n          indexes.forEach((varIndex, i) => {\n            const v = domain_getValue(domains[varIndex]);\n            if (v >= 0) aliases[i] = v;\n          });\n\n          // Do same for param if it's an index\n          let paramName = '';\n          if (typeof constraint.param === 'number') {\n            const paramV = domain_getValue(domains[constraint.param]);\n            if (paramV >= 0) paramName = paramV;\n            else paramName = indexToString(constraint.param);\n          }\n\n          let s = '';\n          let comment = '';\n          let op;\n          switch (constraint.name) {\n            case 'reifier':\n              switch (constraint.param) {\n                case 'eq':\n                  op = '==';\n                  break;\n                case 'neq':\n                  op = '!=';\n                  break;\n                case 'lt':\n                  op = '<';\n                  break;\n                case 'lte':\n                  op = '<=';\n                  break;\n                case 'gt':\n                  op = '>';\n                  break;\n                case 'gte':\n                  op = '>=';\n                  break;\n                default:\n                  THROW('what dis param: ' + op);\n              }\n\n              s +=\n                aliases[2] + ' = ' + aliases[0] + ' ' + op + '? ' + aliases[1];\n              break;\n            case 'plus':\n              s += aliases[2] + ' = ' + aliases[0] + ' + ' + aliases[1];\n              break;\n            case 'min':\n              s += aliases[2] + ' = ' + aliases[0] + ' - ' + aliases[1];\n              break;\n            case 'ring-mul':\n              s += aliases[2] + ' = ' + aliases[0] + ' * ' + aliases[1];\n              break;\n            case 'ring-div':\n              s += aliases[2] + ' = ' + aliases[0] + ' / ' + aliases[1];\n              break;\n            case 'mul':\n              s += aliases[2] + ' = ' + aliases[0] + ' * ' + aliases[1];\n              break;\n            case 'sum':\n              s += paramName + ' = sum(' + aliases.join(' ') + ')';\n              break;\n            case 'product':\n              s += paramName + ' = product(' + aliases.join(' ') + ')';\n              break;\n            case 'markov':\n              s += '# markov(' + aliases + ')';\n              break;\n            case 'distinct':\n              s += 'distinct(' + aliases + ')';\n              break;\n            case 'eq':\n              s += aliases[0] + ' == ' + aliases[1];\n              break;\n            case 'neq':\n              s += aliases[0] + ' != ' + aliases[1];\n              break;\n            case 'lt':\n              s += aliases[0] + ' < ' + aliases[1];\n              break;\n            case 'lte':\n              s += aliases[0] + ' <= ' + aliases[1];\n              break;\n            case 'gt':\n              s += aliases[0] + ' > ' + aliases[1];\n              break;\n            case 'gte':\n              s += aliases[0] + ' >= ' + aliases[1];\n              break;\n\n            default:\n              getTerm().warn('unknown constraint: ' + constraint.name);\n              s += 'unknown = ' + JSON.stringify(constraint);\n          }\n\n          let t = s;\n          // If a constraint has no vars, ignore it.\n          // note: this assumes those constraints are not contradictions\n          if (\n            s.indexOf(realName ? \"'\" : '$') < 0 ||\n            (constraint.name === 'distinct' && aliases.length <= 1) ||\n            ((constraint.name === 'product' || constraint.name === 'sum') &&\n              aliases.length === 0)\n          ) {\n            if (!minimal) {\n              comment +=\n                (comment ? ', ' : ' # ') +\n                'dropped; constraint already solved (' +\n                s +\n                ') (' +\n                indexes.map(indexToString) +\n                ', ' +\n                indexToString(constraint.param) +\n                ')';\n            }\n\n            s = '';\n          }\n\n          if (!minimal || withDomainComments) {\n            // This is more for easier debugging...\n            aliases.forEach((alias, i) => {\n              if (typeof alias === 'string')\n                t = t.replace(alias, exporter_domstr(domains[indexes[i]]));\n            });\n            if (\n              typeof constraint.param === 'number' &&\n              typeof paramName === 'string'\n            )\n              t = t.replace(\n                paramName,\n                exporter_domstr(domains[constraint.param])\n              );\n\n            if (s || !minimal) {\n              // S += ' '.repeat(Math.max(0, 30 - s.length))\n              for (let i = Math.max(0, 30 - s.length); i >= 0; --i) s += ' ';\n              s += '      # ' + t;\n            }\n\n            s += comment;\n          }\n\n          return s;\n        })\n        .filter(s => Boolean(s));\n\n  const propagators = usePropagators\n    ? config._propagators\n        .map(propagator => {\n          const varIndex1 = propagator.index1;\n          const varIndex2 = propagator.index2;\n          const varIndex3 = propagator.index3;\n\n          const v1 = varIndex1 >= 0 ? domain_getValue(domains[varIndex1]) : -1;\n          const name1 =\n            v1 >= 0 ? v1 : varIndex1 < 0 ? undefined : indexToString(varIndex1);\n          const v2 = varIndex2 >= 0 ? domain_getValue(domains[varIndex2]) : -1;\n          const name2 =\n            v2 >= 0 ? v2 : varIndex2 < 0 ? undefined : indexToString(varIndex2);\n          const v3 = varIndex3 >= 0 ? domain_getValue(domains[varIndex3]) : -1;\n          const name3 =\n            v3 >= 0 ? v3 : varIndex3 < 0 ? undefined : indexToString(varIndex3);\n\n          let s = '';\n          let comment = '';\n          let op;\n          switch (propagator.name) {\n            case 'reified':\n              switch (propagator.arg3) {\n                case 'eq':\n                  op = '==';\n                  break;\n                case 'neq':\n                  op = '!=';\n                  break;\n                case 'lt':\n                  op = '<';\n                  break;\n                case 'lte':\n                  op = '<=';\n                  break;\n                case 'gt':\n                  op = '>';\n                  break;\n                case 'gte':\n                  op = '>=';\n                  break;\n                default:\n                  THROW('what dis param: ' + op);\n              }\n\n              s += name3 + ' = ' + name1 + ' ' + op + '? ' + name2;\n              break;\n            case 'eq':\n              s += name1 + ' == ' + name2;\n              break;\n            case 'lt':\n              s += name1 + ' < ' + name2;\n              break;\n            case 'lte':\n              s += name1 + ' <= ' + name2;\n              break;\n            case 'mul':\n              s += name3 + ' = ' + name1 + ' * ' + name2;\n              break;\n            case 'div':\n              s += name3 + ' = ' + name1 + ' / ' + name2;\n              break;\n            case 'neq':\n              s += name1 + ' != ' + name2;\n              break;\n            case 'min':\n              s += name3 + ' = ' + name1 + ' - ' + name2;\n              break;\n\n            case 'ring':\n              switch (propagator.arg1) {\n                case 'plus':\n                  s += name3 + ' = ' + name1 + ' + ' + name2;\n                  break;\n                case 'min':\n                  s += name3 + ' = ' + name1 + ' - ' + name2;\n                  break;\n                case 'ring-mul':\n                  s += name3 + ' = ' + name1 + ' * ' + name2;\n                  break;\n                case 'ring-div':\n                  s += name3 + ' = ' + name1 + ' / ' + name2;\n                  break;\n                default:\n                  throw new Error('Unexpected ring op:' + propagator.arg1);\n              }\n\n              break;\n\n            case 'markov':\n              // ignore. the var @markov modifier should cause this. it's not a real constraint.\n              return '';\n\n            default:\n              getTerm().warn('unknown propagator: ' + propagator.name);\n              s += 'unknown = ' + JSON.stringify(propagator);\n          }\n\n          let t = s;\n\n          // If a propagator has no vars, ignore it.\n          // note: this assumes those constraints are not contradictions\n          if (s.indexOf('$') < 0) {\n            if (!minimal)\n              comment +=\n                (comment ? ', ' : ' # ') +\n                'dropped; constraint already solved (' +\n                s +\n                ')';\n            s = '';\n          }\n\n          if (!minimal) {\n            // This is more for easier debugging...\n\n            if (typeof name1 === 'string')\n              t = t.replace(name1, exporter_domstr(domains[varIndex1]));\n            if (typeof name2 === 'string')\n              t = t.replace(name2, exporter_domstr(domains[varIndex2]));\n            if (typeof name3 === 'string')\n              t = t.replace(name3, exporter_domstr(domains[varIndex3]));\n\n            s +=\n              ' '.repeat(Math.max(0, 30 - s.length)) + '      # initial: ' + t;\n            s += comment;\n          }\n\n          return s;\n        })\n        .filter(s => Boolean(s))\n    : [];\n\n  return [\n    '## constraint problem export',\n    '@custom var-strat = ' + JSON.stringify(config.varStratConfig), // TODO\n    '@custom val-strat = ' + config.valueStratName,\n    vars.join('\\n') || '# no vars',\n    constraints.join('\\n') || propagators.join('\\n') || '# no constraints',\n    '@custom targets ' +\n      (config.targetedVars === 'all'\n        ? ' = all'\n        : '(' +\n          config.targetedVars\n            .map(varName =>\n              indexToString(trie_get(config._varNamesTrie, varName))\n            )\n            .join(' ') +\n          ')'),\n    '## end of export',\n  ].join('\\n\\n');\n}\n\nfunction exporter_encodeVarName(varName) {\n  if (typeof varName === 'number') return varName; // Constant\n  return \"'\" + varName + \"'\"; // \"quoted var names\" can contain any char.\n}\n\nfunction exporter_varstrNum(varIndex) {\n  // Note: we put a `$` behind it so that we can search-n-replace for `$1` without matching `$100`\n  return '$' + varIndex + '$';\n}\n\nfunction exporter_varstrShort(varIndex) {\n  // Take care not to start the name with a number\n  // note: .toString(36) uses a special (standard) base 36 encoding; 0-9a-z to represent 0-35\n  let name = varIndex.toString(36);\n  if (name[0] < 'a') name = '$' + name; // This is a little lazy but whatever\n  return name;\n}\n\nfunction exporter_domstr(domain) {\n  // Represent domains as pairs, a single pair as [lo hi] and multiple as [[lo hi] [lo hi]]\n  let arrdom = domain_toArr(domain);\n  if (arrdom.length === 2 && arrdom[0] === arrdom[1]) return String(arrdom[0]);\n  if (arrdom.length > 2) {\n    const dom = [];\n    for (let i = 0, n = arrdom.length; i < n; i += 2) {\n      dom.push('[' + arrdom[i] + ' ' + arrdom[i + 1] + ']');\n    }\n\n    arrdom = dom;\n  }\n\n  return '[' + arrdom.join(' ') + ']';\n}\n\nexport { exporter, exporter_encodeVarName };\n","// This is an import function for config\n// it converts a DSL string to a $config\n// see /docs/dsl.txt for syntax\n// see exporter.js to convert a config to this DSL\n\nimport { SUB, SUP, getTerm } from 'fdlib';\n\nimport { config_setOption } from './config';\n\nimport FDO from './fdo';\n\n/**\n * @param {string} str\n * @param {FDO} [solver]\n * @param {boolean} [_debug] Log out entire input with error token on fail?\n * @returns {FDO}\n */\nfunction importer(str, solver, _debug) {\n  if (!solver) solver = new FDO();\n\n  let pointer = 0;\n  const len = str.length;\n\n  while (!isEof()) parseStatement();\n\n  return solver;\n\n  function read() {\n    return str[pointer];\n  }\n\n  function readD(delta) {\n    return str[pointer + delta];\n  }\n\n  function skip() {\n    ++pointer;\n  }\n\n  function is(c, desc) {\n    if (read() !== c)\n      THROW(\n        'Expected ' +\n          (desc ? desc + ' ' : '') +\n          '`' +\n          c +\n          '`, found `' +\n          read() +\n          '`'\n      );\n    skip();\n  }\n\n  function skipWhitespaces() {\n    while (pointer < len && isWhitespace(read())) skip();\n  }\n\n  function skipWhites() {\n    while (!isEof()) {\n      const c = read();\n      if (isWhite(c)) {\n        skip();\n      } else if (isComment(c)) {\n        skipComment();\n      } else {\n        break;\n      }\n    }\n  }\n\n  function isWhitespace(s) {\n    return s === ' ' || s === '\\t';\n  }\n\n  function isNewline(s) {\n    return s === '\\n' || s === '\\r';\n  }\n\n  function isComment(s) {\n    return s === '#';\n  }\n\n  function isWhite(s) {\n    return isWhitespace(s) || isNewline(s);\n  }\n\n  function expectEol() {\n    skipWhitespaces();\n    if (pointer < len) {\n      const c = read();\n      if (c === '#') {\n        skipComment();\n      } else if (isNewline(c)) {\n        skip();\n      } else {\n        THROW('Expected EOL but got `' + read() + '`');\n      }\n    }\n  }\n\n  function atEol() {\n    if (pointer >= len) return true;\n    const c = read();\n    return c === '#' || isNewline(c);\n  }\n\n  function isEof() {\n    return pointer >= len;\n  }\n\n  function parseStatement() {\n    // Either:\n    // - start with colon: var decl\n    // - start with hash: line comment\n    // - empty: empty\n    // - otherwise: constraint\n\n    skipWhites();\n    switch (read()) {\n      case ':':\n        return parseVar();\n      case '#':\n        return skipComment();\n      case '@':\n        return parseAtRule();\n      default:\n        if (!isEof()) return parseUndefConstraint();\n    }\n  }\n\n  function parseVar() {\n    skip(); // Is(':')\n    skipWhitespaces();\n\n    let nameNames = parseIdentifier();\n    skipWhitespaces();\n    if (read() === ',') {\n      nameNames = [nameNames];\n      do {\n        skip();\n        skipWhitespaces();\n        nameNames.push(parseIdentifier());\n        skipWhitespaces();\n      } while (!isEof() && read() === ',');\n    }\n\n    if (read() === '=') {\n      skip();\n      skipWhitespaces();\n    }\n\n    const domain = parseDomain();\n    skipWhitespaces();\n\n    const mod = parseModifier();\n    expectEol();\n\n    if (typeof nameNames === 'string') {\n      solver.decl(nameNames, domain, mod, true);\n    } else {\n      nameNames.forEach(name => solver.decl(name, domain, mod, true));\n    }\n  }\n\n  function parseIdentifier() {\n    if (read() === \"'\") return parseQuotedIdentifier();\n    return parseUnquotedIdentifier();\n  }\n\n  function parseQuotedIdentifier() {\n    is(\"'\", 'start of Quoted identifier');\n\n    const start = pointer;\n    let c = read();\n    while (!isEof() && !isNewline(c) && c !== \"'\") {\n      skip();\n      c = read();\n    }\n\n    if (isEof()) THROW('Quoted identifier must be closed');\n    if (start === pointer) THROW('Expected to parse identifier, found none');\n    is(\"'\", 'end of Quoted identifier');\n    return str.slice(start, pointer - 1); // Return unquoted ident\n  }\n\n  function parseUnquotedIdentifier() {\n    // Anything terminated by whitespace\n    const start = pointer;\n    if (read() >= '0' && read() <= '9')\n      THROW('Unquoted ident cant start with number');\n    while (!isEof() && isValidUnquotedIdentChar(read())) skip();\n    if (start === pointer)\n      THROW('Expected to parse identifier, found none [' + read() + ']');\n    return str.slice(start, pointer);\n  }\n\n  function isValidUnquotedIdentChar(c) {\n    // Meh. i syntactically dont care about unicode chars so if you want to use them i wont stop you here\n    return (\n      (c >= 'a' && c <= 'z') ||\n      (c >= 'A' && c <= 'Z') ||\n      (c >= '0' && c <= '9') ||\n      c === '_' ||\n      c === '$' ||\n      c === '-' ||\n      c > '~'\n    );\n  }\n\n  function parseDomain() {\n    // []\n    // [lo hi]\n    // [[lo hi] [lo hi] ..]\n    // *\n    // 25\n    // (comma's optional and ignored)\n\n    const c = read();\n\n    let domain;\n    switch (c) {\n      case '[':\n        is('[', 'domain start');\n        skipWhitespaces();\n\n        domain = [];\n\n        if (read() === '[') {\n          do {\n            skip();\n            skipWhitespaces();\n            const lo = parseNumber();\n            skipWhitespaces();\n            if (read() === ',') {\n              skip();\n              skipWhitespaces();\n            }\n\n            const hi = parseNumber();\n            skipWhitespaces();\n            is(']', 'range-end');\n            skipWhitespaces();\n\n            domain.push(lo, hi);\n\n            if (read() === ',') {\n              skip();\n              skipWhitespaces();\n            }\n          } while (read() === '[');\n        } else if (read() !== ']') {\n          do {\n            skipWhitespaces();\n            const lo = parseNumber();\n            skipWhitespaces();\n            if (read() === ',') {\n              skip();\n              skipWhitespaces();\n            }\n\n            const hi = parseNumber();\n            skipWhitespaces();\n\n            domain.push(lo, hi);\n\n            if (read() === ',') {\n              skip();\n              skipWhitespaces();\n            }\n          } while (read() !== ']');\n        }\n\n        is(']', 'domain-end');\n        if (domain.length === 0)\n          THROW('Empty domain [] in dsl, this problem will always reject');\n        return domain;\n\n      case '*':\n        skip();\n        return [SUB, SUP];\n\n      case '0':\n      case '1':\n      case '2':\n      case '3':\n      case '4':\n      case '5':\n      case '6':\n      case '7':\n      case '8':\n      case '9': {\n        const v = parseNumber();\n        skipWhitespaces();\n        return [v, v];\n      }\n\n      default:\n        THROW('Expecting valid domain start, found `' + c + '`');\n    }\n  }\n\n  function parseModifier() {\n    if (read() !== '@') return;\n    skip();\n\n    const mod = {};\n\n    const start = pointer;\n    while (read() >= 'a' && read() <= 'z') skip();\n    const stratName = str.slice(start, pointer);\n\n    switch (stratName) {\n      case 'list':\n        parseList(mod);\n        break;\n\n      case 'markov':\n        parseMarkov(mod);\n        break;\n\n      case 'max':\n      case 'mid':\n      case 'min':\n      case 'naive':\n        break;\n\n      case 'minMaxCycle':\n      case 'splitMax':\n      case 'splitMin':\n      default:\n        THROW('implement me (var mod) [`' + stratName + '`]');\n    }\n\n    mod.valtype = stratName;\n\n    return mod;\n  }\n\n  function parseList(mod) {\n    skipWhitespaces();\n    if (str.slice(pointer, pointer + 5) !== 'prio(')\n      THROW('Expecting the priorities to follow the `@list`');\n    pointer += 5;\n    mod.list = parseNumList();\n    is(')', 'list end');\n  }\n\n  function parseMarkov(mod) {\n    for (;;) {\n      skipWhitespaces();\n      if (str.slice(pointer, pointer + 7) === 'matrix(') {\n        // TOFIX: there is no validation here. apply stricter and safe matrix parsing\n        const matrix = str.slice(\n          pointer + 7,\n          (pointer = str.indexOf(')', pointer))\n        );\n        const code = 'return ' + matrix;\n        const func = new Function(code); /* eslint no-new-func: \"off\" */\n        mod.matrix = func();\n        if (pointer === -1)\n          THROW('The matrix must be closed by a `)` but did not find any');\n      } else if (str.slice(pointer, pointer + 7) === 'legend(') {\n        pointer += 7;\n        mod.legend = parseNumList();\n        skipWhitespaces();\n        is(')', 'legend closer');\n      } else if (str.slice(pointer, pointer + 7) === 'expand(') {\n        pointer += 7;\n        mod.expandVectorsWith = parseNumber();\n        skipWhitespaces();\n        is(')', 'expand closer');\n      } else {\n        break;\n      }\n\n      skip();\n    }\n  }\n\n  function skipComment() {\n    is('#', 'comment start'); // Is('#', 'comment hash');\n    while (!isEof() && !isNewline(read())) skip();\n    if (!isEof()) skip();\n  }\n\n  function parseUndefConstraint() {\n    // Parse a constraint that does not return a value itself\n\n    // first try to parse single value constraints without value like markov() and distinct()\n    if (parseUexpr()) return;\n\n    // So the first value must be a value returning expr\n    const A = parseVexpr(); // Returns a var name or a constant value\n\n    skipWhitespaces();\n    const cop = parseCop();\n    skipWhitespaces();\n    switch (cop) {\n      case '=':\n        parseAssignment(A);\n        break;\n\n      case '==':\n        solver.eq(A, parseVexpr());\n        break;\n\n      case '!=':\n        solver.neq(A, parseVexpr());\n        break;\n\n      case '<':\n        solver.lt(A, parseVexpr());\n        break;\n\n      case '<=':\n        solver.lte(A, parseVexpr());\n        break;\n\n      case '>':\n        solver.gt(A, parseVexpr());\n        break;\n\n      case '>=':\n        solver.gte(A, parseVexpr());\n        break;\n\n      case '&':\n        // Force A and B to non-zero (artifact)\n        // (could easily be done at compile time)\n        // for now we mul the args and force the result non-zero, this way neither arg can be zero\n        // TODO: this could be made \"safer\" with more work; `(A/A)+(B/B) > 0` doesnt risk going oob, i think. and otherwise we could sum two ==?0 reifiers to equal 2. just relatively very expensive.\n        solver.neq(solver.mul(A, parseVexpr()), solver.num(0));\n        break;\n\n      case '!&':\n        // Nand is a nall with just two args...\n        // it is the opposite from AND, and so is the implementation\n        // (except since we can force to 0 instead of \"nonzero\" we can drop the eq wrapper)\n        solver.mul(A, parseVexpr(), solver.num(0));\n        break;\n\n      case '|':\n        // Force at least one of A and B to be non-zero (both is fine too)\n        // if we add both args and check the result for non-zero then at least one arg must be non-zero\n        solver.neq(solver.plus(A, parseVexpr()), solver.num(0));\n        break;\n\n      case '!|':\n        // Unconditionally force A and B to zero\n        solver.eq(A, solver.num(0));\n        solver.eq(parseVexpr(), solver.num(0));\n        break;\n\n      case '^':\n        // Force A zero and B nonzero or A nonzero and B zero (anything else rejects)\n        // this is more tricky/expensive to implement than AND and OR...\n        // x=A+B,x==A^x==B owait\n        // (A==?0)+(B==?0)==1\n        solver.eq(\n          solver.plus(solver.isEq(A, 0), solver.isEq(parseVexpr(), 0)),\n          1\n        );\n        break;\n\n      case '!^':\n        // Xor means A and B both solve to zero or both to non-zero\n        // (A==?0)==(B==?0)\n        solver.eq(\n          solver.isEq(A, solver.num(0)),\n          solver.isEq(parseVexpr(), solver.num(0))\n        );\n        break;\n\n      case '->': {\n        // I think this could be implemented in various ways\n        // A -> B     =>    ((A !=? 0) <= (B !=? 0)) & ((B ==? 0) <= (A ==? 0))\n        // (if A is nonzero then B must be nonzero, otherwise B can be anything. But also if B is zero then\n        // A must be zero and otherwise A can be anything. They must both hold to simulate an implication.)\n        const B = parseVexpr();\n        // (A !=? 0) <= (B !=? 0))\n        solver.lte(\n          solver.isNeq(A, solver.num(0)),\n          solver.isNeq(B, solver.num(0))\n        );\n        // (B ==? 0) <= (A ==? 0)\n        solver.lte(\n          solver.isEq(B, solver.num(0)),\n          solver.isEq(A, solver.num(0))\n        );\n        break;\n      }\n\n      case '!->':\n        // Force A to nonzero and B to zero\n        solver.gt(A, solver.num(0));\n        solver.eq(parseVexpr(), solver.num(0));\n        break;\n\n      default:\n        if (cop) THROW('Unknown cop that starts with: [' + cop + ']');\n    }\n\n    expectEol();\n  }\n\n  function parseAssignment(C) {\n    // Note: if FDO api changes this may return the wrong value...\n    // it should always return the \"result var\" var name or constant\n    // (that would be C, but C may be undefined here and created by FDO)\n\n    const freshVar = typeof C === 'string' && !solver.hasVar(C);\n    if (freshVar) C = solver.decl(C);\n\n    const A = parseVexpr(C, freshVar);\n    skipWhitespaces();\n    const c = read();\n    if (isEof() || isNewline(c) || isComment(c)) {\n      // Any group without \"top-level\" op (`A=(B+C)`), or sum() etc\n      // but also something like `x = 5` (which we cant detect here)\n      // so just to make sure those cases dont fall through add an\n      // extra eq. this should resolve immediately without change to\n      // cases like `x = sum()`\n      solver.eq(A, C);\n      return A;\n    }\n\n    return parseAssignRest(A, C, freshVar);\n  }\n\n  function parseAssignRest(A, C, freshVar) {\n    const rop = parseRop();\n    skipWhitespaces();\n    switch (rop) {\n      case '==?':\n        if (freshVar) solver.decl(C, [0, 1], undefined, false, true);\n        return solver.isEq(A, parseVexpr(), C);\n      case '!=?':\n        if (freshVar) solver.decl(C, [0, 1], undefined, false, true);\n        return solver.isNeq(A, parseVexpr(), C);\n      case '<?':\n        if (freshVar) solver.decl(C, [0, 1], undefined, false, true);\n        return solver.isLt(A, parseVexpr(), C);\n      case '<=?':\n        if (freshVar) solver.decl(C, [0, 1], undefined, false, true);\n        return solver.isLte(A, parseVexpr(), C);\n      case '>?':\n        if (freshVar) solver.decl(C, [0, 1], undefined, false, true);\n        return solver.isGt(A, parseVexpr(), C);\n      case '>=?':\n        if (freshVar) solver.decl(C, [0, 1], undefined, false, true);\n        return solver.isGte(A, parseVexpr(), C);\n      case '|?':\n        if (freshVar) solver.decl(C, [0, 1], undefined, false, true);\n        return compileIssome(C, [A, parseVexpr()]);\n      case '!|?':\n        if (freshVar) solver.decl(C, [0, 1], undefined, false, true);\n        return compileIsnone(C, [A, parseVexpr()]);\n      case '&?':\n        if (freshVar) solver.decl(C, [0, 1], undefined, false, true);\n        return compileIsall(C, [A, parseVexpr()]);\n      case '!&?':\n        if (freshVar) solver.decl(C, [0, 1], undefined, false, true);\n        return compileIsnall(C, [A, parseVexpr()]);\n      case '+':\n        return solver.plus(A, parseVexpr(), C);\n      case '-':\n        return solver.minus(A, parseVexpr(), C);\n      case '*':\n        return solver.mul(A, parseVexpr(), C);\n      case '/':\n        return solver.div(A, parseVexpr(), C);\n      default:\n        if (rop !== undefined)\n          THROW('Expecting right paren or rop, got: `' + rop + '`');\n        return A;\n    }\n  }\n\n  function parseCop() {\n    let c = read();\n    switch (c) {\n      case '=':\n        skip();\n        if (read() === '=') {\n          skip();\n          return '==';\n        }\n\n        return '=';\n      case '!':\n        skip();\n        c = read();\n        if (c === '=') {\n          skip();\n          return '!=';\n        }\n\n        if (c === '&') {\n          skip();\n          return '!&';\n        }\n\n        if (c === '^') {\n          skip();\n          return '!^';\n        }\n\n        if (c === '|') {\n          skip();\n          return '!|';\n        }\n\n        if (c === '-' && readD(1) === '>') {\n          skip();\n          skip();\n          return '!->';\n        }\n\n        return '!';\n      case '<':\n        skip();\n        if (read() === '=') {\n          skip();\n          return '<=';\n        }\n\n        return '<';\n      case '>':\n        skip();\n        if (read() === '=') {\n          skip();\n          return '>=';\n        }\n\n        return '>';\n      case '&':\n      case '|':\n      case '^':\n        skip();\n        return c;\n      case '#':\n        THROW('Expected to parse a cop but found a comment instead');\n        break;\n      case '-':\n        if (readD(1) === '>') {\n          skip();\n          skip();\n          return '->';\n        }\n\n        break;\n      default:\n        break;\n    }\n\n    if (isEof()) THROW('Expected to parse a cop but reached eof instead');\n    THROW('Unknown cop char: `' + c + '`');\n  }\n\n  function parseRop() {\n    const a = read();\n    switch (a) {\n      case '=': {\n        skip();\n        const b = read();\n        if (b === '=') {\n          skip();\n          is('?', 'reifier suffix');\n          return '==?';\n        }\n\n        return '=';\n      }\n\n      case '!':\n        skip();\n        if (read() === '=') {\n          is('=', 'middle part of !=? op');\n          is('?', 'reifier suffix');\n          return '!=?';\n        }\n\n        if (read() === '|') {\n          is('|', 'middle part of !|? op');\n          is('?', 'reifier suffix');\n          return '!|?';\n        }\n\n        if (read() === '&') {\n          is('&', 'middle part of !&? op');\n          is('?', 'reifier suffix');\n          return '!&?';\n        }\n\n        THROW('invalid rop char after ! [' + read() + ']');\n        break;\n\n      case '<':\n        skip();\n        if (read() === '=') {\n          skip();\n          is('?', 'reifier suffix');\n          return '<=?';\n        }\n\n        is('?', 'reifier suffix');\n        return '<?';\n\n      case '>':\n        skip();\n        if (read() === '=') {\n          skip();\n          is('?', 'reifier suffix');\n          return '>=?';\n        }\n\n        is('?', 'reifier suffix');\n        return '>?';\n\n      case '|':\n        skip();\n        is('?', 'reifier suffix');\n        return '|?';\n      case '&':\n        skip();\n        is('?', 'reifier suffix');\n        return '&?';\n\n      case '+':\n      case '-':\n      case '*':\n      case '/':\n        skip();\n        return a;\n\n      default:\n        THROW('Expecting right paren or rop, got: `' + a + '`');\n    }\n  }\n\n  function parseUexpr() {\n    // It's not very efficient (we could parse an ident before and check that result here) but it'll work for now\n    if (str.slice(pointer, pointer + 4) === 'all(') parseAll();\n    else if (str.slice(pointer, pointer + 9) === 'distinct(') parseDistinct(9);\n    else if (str.slice(pointer, pointer + 5) === 'diff(') parseDistinct(5);\n    else if (str.slice(pointer, pointer + 5) === 'nall(') parseNall();\n    else if (str.slice(pointer, pointer + 5) === 'none(') parseNone();\n    else if (str.slice(pointer, pointer + 5) === 'same(') parseSame();\n    else if (str.slice(pointer, pointer + 5) === 'some(') parseSome();\n    else if (str.slice(pointer, pointer + 5) === 'xnor(') parseXnor();\n    else return false;\n\n    return true;\n  }\n\n  function parseVexpList() {\n    const list = [];\n    skipWhitespaces();\n    while (!isEof() && read() !== ')') {\n      const v = parseVexpr();\n      list.push(v);\n\n      skipWhitespaces();\n      if (read() === ',') {\n        skip();\n        skipWhitespaces();\n      }\n    }\n\n    return list;\n  }\n\n  function parseVexpr(resultVar, freshVar) {\n    // Valcall, ident, number, group\n\n    const c = read();\n    let v;\n    if (c === '(') v = parseGrouping();\n    else if (c === '[') {\n      const d = parseDomain();\n      if (d[0] === d[1] && d.length === 2) v = d[0];\n      else v = solver.decl(undefined, d);\n    } else if (c >= '0' && c <= '9') {\n      v = parseNumber();\n    } else {\n      const ident = parseIdentifier();\n      const d = read();\n      if (ident === 'sum' && d === '(') {\n        v = parseSum(resultVar);\n      } else if (ident === 'product' && d === '(') {\n        v = parseProduct(resultVar);\n      } else if (ident === 'all' && d === '?' && (skip(), read() === '(')) {\n        if (freshVar) solver.decl(resultVar, [0, 1], undefined, false, true);\n        v = parseIsAll(resultVar);\n      } else if (ident === 'diff' && d === '?' && (skip(), read() === '(')) {\n        if (freshVar) solver.decl(resultVar, [0, 1], undefined, false, true);\n        v = parseIsDiff(resultVar);\n      } else if (ident === 'nall' && d === '?' && (skip(), read() === '(')) {\n        if (freshVar) solver.decl(resultVar, [0, 1], undefined, false, true);\n        v = parseIsNall(resultVar);\n      } else if (ident === 'none' && d === '?' && (skip(), read() === '(')) {\n        if (freshVar) solver.decl(resultVar, [0, 1], undefined, false, true);\n        v = parseIsNone(resultVar);\n      } else if (ident === 'same' && d === '?' && (skip(), read() === '(')) {\n        if (freshVar) solver.decl(resultVar, [0, 1], undefined, false, true);\n        v = parseIsSame(resultVar);\n      } else if (ident === 'some' && d === '?' && (skip(), read() === '(')) {\n        if (freshVar) solver.decl(resultVar, [0, 1], undefined, false, true);\n        v = parseIsSome(resultVar);\n      } else if (d === '?') {\n        THROW('Unknown reifier constraint func: [' + ident + ']');\n      } else {\n        v = ident;\n      }\n    }\n\n    return v;\n  }\n\n  function parseGrouping() {\n    is('(', 'group open');\n    skipWhitespaces();\n    const A = parseVexpr();\n    skipWhitespaces();\n\n    if (read() === '=') {\n      if (read() !== '=') {\n        parseAssignment(A);\n        skipWhitespaces();\n        is(')', 'group closer');\n        return A;\n      }\n    }\n\n    if (read() === ')') {\n      // Just wrapping a vexpr is okay\n      skip();\n      return A;\n    }\n\n    const C = parseAssignRest(A);\n    skipWhitespaces();\n    is(')', 'group closer');\n    return C;\n  }\n\n  function parseNumber() {\n    const start = pointer;\n    while (read() >= '0' && read() <= '9') skip();\n    if (start === pointer) {\n      THROW(\n        'Expecting to parse a number but did not find any digits [' +\n          start +\n          ',' +\n          pointer +\n          '][' +\n          read() +\n          ']'\n      );\n    }\n\n    return parseInt(str.slice(start, pointer), 10);\n  }\n\n  function parseAll() {\n    pointer += 4;\n    skipWhitespaces();\n    const refs = parseVexpList();\n    // R can only be 0 if (at least) one of the args is zero. so by removing\n    // 0 from R's domain we require all args nonzero. cheap hack.\n    const r = solver.product(refs, solver.decl(undefined, [1, SUP]));\n    skipWhitespaces();\n    is(')', 'ALL closer');\n    return r;\n  }\n\n  function parseDistinct(delta) {\n    pointer += delta;\n    skipWhitespaces();\n    const vals = parseVexpList();\n    if (vals.length === 0) THROW('Expecting at least one expression');\n    solver.distinct(vals);\n    skipWhitespaces();\n    is(')', 'distinct call closer');\n    expectEol();\n  }\n\n  function parseSum(result) {\n    is('(', 'sum call opener');\n    skipWhitespaces();\n    const refs = parseVexpList();\n    const r = solver.sum(refs, result);\n    skipWhitespaces();\n    is(')', 'sum closer');\n    return r;\n  }\n\n  function parseProduct(result) {\n    is('(', 'product call opener');\n    skipWhitespaces();\n    const refs = parseVexpList();\n    const r = solver.product(refs, result);\n    skipWhitespaces();\n    is(')', 'product closer');\n    return r;\n  }\n\n  function parseIsAll(result) {\n    is('(', 'isall call opener');\n    skipWhitespaces();\n    const refs = parseVexpList();\n\n    const r = compileIsall(result, refs);\n    skipWhitespaces();\n    is(')', 'isall closer');\n    return r;\n  }\n\n  function compileIsall(result, args) {\n    // R = all?(A B C ...)   ->   X = A * B * C * ..., R = X !=? 0\n\n    const x = solver.decl(); // Anon var [sub,sup]\n    solver.product(args, x);\n    return solver.isNeq(x, solver.num(0), result);\n  }\n\n  function parseIsDiff(result) {\n    is('(', 'isdiff call opener');\n    skipWhitespaces();\n    const refs = parseVexpList();\n\n    // R = diff?(A B C ...)\n    // =>\n    // x e args, y e args, x!=y\n    // =>\n    // Rxy = dom(x) !=? dom(y)\n    // c = sum(Rxy ...)\n    // R = c ==? argCount\n\n    const reifs = [];\n\n    for (let i = 0; i < refs.length; ++i) {\n      const indexA = refs[i];\n      for (let j = i + 1; j < refs.length; ++j) {\n        const indexB = refs[j];\n        reifs.push(solver.isNeq(indexA, indexB));\n      }\n    }\n\n    solver.isEq(solver.sum(reifs), solver.num(reifs.length), result);\n\n    skipWhitespaces();\n    is(')', 'isdiff closer');\n    return result;\n  }\n\n  function parseIsNall(result) {\n    is('(', 'isnall call opener');\n    skipWhitespaces();\n    const refs = parseVexpList();\n    const r = compileIsnall(result, refs);\n    skipWhitespaces();\n    is(')', 'isnall closer');\n    return r;\n  }\n\n  function compileIsnall(result, args) {\n    // R = nall?(A B C ...)   ->   X = A * B * C * ..., R = X ==? 0\n\n    const x = solver.decl(); // Anon var [sub,sup]\n    solver.product(args, x);\n    return solver.isEq(x, solver.num(0), result);\n  }\n\n  function parseIsNone(result) {\n    is('(', 'isnone call opener');\n    skipWhitespaces();\n    const refs = parseVexpList();\n    const r = compileIsnone(result, refs);\n    skipWhitespaces();\n    is(')', 'isnone closer');\n    return r;\n  }\n\n  function compileIsnone(result, args) {\n    // R = none?(A B C ...)   ->   X = sum(A B C ...), R = X ==? 0\n\n    const x = solver.decl(); // Anon var [sub,sup]\n    solver.sum(args, x);\n    return solver.isEq(x, solver.num(0), result);\n  }\n\n  function parseIsSame(result) {\n    is('(', 'issame call opener');\n    skipWhitespaces();\n    const refs = parseVexpList();\n\n    // R = same?(A B C ...)   ->   A==?B,B==?C,C==?..., sum(reifs) === reifs.length\n\n    const reifs = [];\n    for (let i = 1; i < refs.length; ++i) {\n      const r = solver.decl(undefined, [0, 1]);\n      solver.isEq(refs[i - 1], refs[i], r);\n      reifs.push(r);\n    }\n\n    const x = solver.decl(); // Anon var [sub,sup]\n    solver.sum(reifs, x);\n\n    const r = solver.isEq(x, solver.num(reifs.length), result);\n\n    skipWhitespaces();\n    is(')', 'issame closer');\n    return r;\n  }\n\n  function parseIsSome(result) {\n    is('(', 'issome call opener');\n    skipWhitespaces();\n    const refs = parseVexpList();\n    const r = compileIssome(result, refs);\n    skipWhitespaces();\n    is(')', 'issome closer');\n    return r;\n  }\n\n  function compileIssome(result, args) {\n    // R = some?(A B C ...)   ->   X = sum(A B C ...), R = X !=? 0\n\n    const x = solver.decl(); // Anon var [sub,sup]\n    solver.sum(args, x);\n    return solver.isNeq(x, solver.num(0), result);\n  }\n\n  function parseNall() {\n    pointer += 5;\n    skipWhitespaces();\n    const refs = parseVexpList();\n    // TODO: could also sum reifiers but i think this is way more efficient. for the time being.\n    solver.product(refs, solver.num(0));\n    skipWhitespaces();\n    is(')', 'nall closer');\n    expectEol();\n  }\n\n  function parseNone() {\n    pointer += 5;\n    skipWhitespaces();\n    const refs = parseVexpList();\n    solver.sum(refs, solver.num(0)); // Lazy way out but should resolve immediately anyways\n    skipWhitespaces();\n    is(')', 'none closer');\n    expectEol();\n  }\n\n  function parseSame() {\n    pointer += 5;\n    skipWhitespaces();\n    const refs = parseVexpList();\n    for (let i = 1; i < refs.length; ++i) {\n      solver.eq(refs[i - 1], refs[i]);\n    }\n\n    skipWhitespaces();\n    is(')', 'same closer');\n    expectEol();\n  }\n\n  function parseSome() {\n    pointer += 5;\n    skipWhitespaces();\n    const refs = parseVexpList();\n    solver.sum(refs, solver.decl(undefined, [1, SUP]));\n    skipWhitespaces();\n    is(')', 'some closer');\n    expectEol();\n  }\n\n  function parseXnor() {\n    pointer += 5;\n    skipWhitespaces();\n    const refs = parseVexpList();\n    skipWhitespaces();\n    is(')', 'xnor() closer');\n    expectEol();\n\n    // Xnor(A B C)\n    // =>\n    // x=X+B+C                  (if x is 0, all the args were zero: \"none\")\n    // y=X*B*C                  (if y is not 0, none of the args were zero: \"all\")\n    // (x==0) + (y!=0) == 1     (must all be zero or all be nonzero)\n\n    const x = solver.decl(); // Anon var [sub,sup]\n    const y = solver.decl(); // Anon var [sub,sup]\n    solver.sum(refs, x);\n    solver.product(refs, y);\n    solver.plus(solver.isEq(x, 0), solver.isNeq(y, 0), 1);\n  }\n\n  function parseNumstr() {\n    const start = pointer;\n    while (read() >= '0' && read() <= '9') skip();\n    return str.slice(start, pointer);\n  }\n\n  function parseNumList() {\n    const nums = [];\n\n    skipWhitespaces();\n    let numstr = parseNumstr();\n    while (numstr) {\n      nums.push(parseInt(numstr, 10));\n      skipWhitespaces();\n      if (read() === ',') {\n        ++pointer;\n        skipWhitespaces();\n      }\n\n      numstr = parseNumstr();\n    }\n\n    if (nums.length === 0)\n      THROW('Expected to parse a list of at least some numbers but found none');\n    return nums;\n  }\n\n  function parseIdentList() {\n    const idents = [];\n\n    for (;;) {\n      skipWhitespaces();\n      if (atEol()) THROW('Missing target char at eol/eof');\n      if (read() === ')') break;\n      if (read() === ',') {\n        skip();\n        skipWhitespaces();\n        if (atEol()) THROW('Trailing comma not supported');\n      }\n\n      if (read() === ',') THROW('Double comma not supported');\n      const ident = parseIdentifier();\n      idents.push(ident);\n    }\n\n    if (idents.length === 0)\n      THROW(\n        'Expected to parse a list of at least some identifiers but found none'\n      );\n    return idents;\n  }\n\n  function readLine() {\n    let line = '';\n    while (!isEof() && !isNewline(read())) {\n      line += read();\n      skip();\n    }\n\n    return line;\n  }\n\n  function parseAtRule() {\n    is('@');\n    // Mostly temporary hacks while the dsl stabilizes...\n\n    if (str.slice(pointer, pointer + 6) === 'custom') {\n      pointer += 6;\n      skipWhitespaces();\n      const ident = parseIdentifier();\n      skipWhitespaces();\n      if (read() === '=') {\n        skip();\n        skipWhitespaces();\n        if (read() === '=') THROW('Unexpected double eq sign');\n      }\n\n      switch (ident) {\n        case 'var-strat':\n          parseVarStrat();\n          break;\n        case 'val-strat':\n          parseValStrat();\n          break;\n        case 'set-valdist': {\n          skipWhitespaces();\n          const target = parseIdentifier();\n          const config = parseRestCustom();\n          solver.setValueDistributionFor(target, JSON.parse(config));\n          break;\n        }\n\n        case 'targets':\n          parseTargets();\n          break;\n        case 'nobool':\n        case 'noleaf':\n        case 'free':\n          skipWhitespaces();\n          if (read() === ',') THROW('Leading comma not supported');\n          if (atEol()) THROW('Expected to parse some var values');\n          // ignore. it's a presolver debug tool\n          readLine();\n          break;\n        default:\n          THROW('Unsupported custom rule: ' + ident);\n      }\n    } else {\n      THROW('Unknown atrule');\n    }\n\n    expectEol();\n  }\n\n  function parseVarStrat() {\n    // @custom var-strat [fallback] [=] naive\n    // @custom var-strat [fallback] [=] size\n    // @custom var-strat [fallback] [=] min\n    // @custom var-strat [fallback] [=] max\n    // @custom var-strat [fallback] [=] throw\n    // @custom var-strat [fallback] [inverted] [list] (a b c)\n\n    skipWhitespaces();\n\n    let fallback = false;\n    if (read() === 'f') {\n      // Inverted\n      const ident = parseIdentifier();\n      if (ident !== 'fallback') THROW('Expecting `fallback` here');\n      fallback = true;\n      skipWhitespaces();\n    }\n\n    let inverted = false;\n    if (read() === 'i') {\n      // Inverted\n      const ident = parseIdentifier();\n      if (ident !== 'inverted') THROW('Expecting `inverted` here');\n      inverted = true;\n      skipWhitespaces();\n    }\n\n    if (read() === 'l' || read() === '(') {\n      if (read() === 'l') {\n        // List (optional keyword)\n        if (parseIdentifier() !== 'list')\n          THROW(\n            'Unexpected ident after `inverted` (only expecting `list` or the list)'\n          );\n        skipWhitespaces();\n      }\n\n      is('(');\n      const priorityByName = parseIdentList();\n      if (priorityByName.length > 0)\n        config_setOption(\n          solver.config,\n          fallback ? 'varStrategyFallback' : 'varStrategy',\n          { type: 'list', inverted, priorityByName }\n        );\n      else\n        config_setOption(\n          solver.config,\n          fallback ? 'varStrategyFallback' : 'varStrategy',\n          { type: 'naive' }\n        );\n      skipWhitespaces();\n      is(')');\n    } else {\n      if (read() === '=') {\n        skip();\n        skipWhitespaces();\n      }\n\n      if (inverted)\n        THROW('The `inverted` keyword is only valid for a prio list');\n      // Parse ident and use that as the vardist\n      const ident = parseIdentifier();\n      if (ident === 'list')\n        THROW('Use a grouped list of idents for vardist=list');\n      if (\n        ident !== 'naive' &&\n        ident !== 'size' &&\n        ident !== 'min' &&\n        ident !== 'max' &&\n        ident !== 'throw'\n      )\n        THROW('Unknown var dist [' + ident + ']');\n      config_setOption(\n        solver.config,\n        fallback ? 'varStrategyFallback' : 'varStrategy',\n        { type: ident }\n      );\n    }\n  }\n\n  function parseValStrat() {\n    const name = parseIdentifier();\n    expectEol();\n    solver.config.valueStratName = name;\n  }\n\n  function parseRestCustom() {\n    skipWhitespaces();\n    if (read() === '=') {\n      skip();\n      skipWhitespaces();\n    }\n\n    return readLine();\n  }\n\n  function parseTargets() {\n    skipWhitespaces();\n\n    if (str.slice(pointer, pointer + 3) === 'all') {\n      pointer += 3;\n      solver.config.targetedVars = 'all';\n    } else {\n      is('(', 'ONLY_USE_WITH_SOME_TARGET_VARS');\n      skipWhitespaces();\n      if (read() === ',') THROW('Leading comma not supported');\n      const idents = parseIdentList();\n      if (idents.length > 0) solver.config.targetedVars = idents;\n      is(')');\n    }\n  }\n\n  function THROW(msg) {\n    if (_debug) {\n      getTerm().log(\n        str.slice(0, pointer) +\n          '##|PARSER_IS_HERE[' +\n          msg +\n          ']|##' +\n          str.slice(pointer)\n      );\n    }\n\n    msg =\n      'Importer parser error: ' +\n      msg +\n      ', source at #|#: `' +\n      str.slice(Math.max(0, pointer - 70), pointer) +\n      '#|#' +\n      str.slice(pointer, Math.min(str.length, pointer + 70)) +\n      '`';\n    throw new Error(msg);\n  }\n}\n\nexport { importer };\n","import {\n  ASSERT,\n  ASSERT_LOG,\n  ASSERT_NORDOM,\n  LOG_FLAG_PROPSTEPS,\n  NO_SUCH_VALUE,\n  domain__debug,\n  domain_getValue,\n  domain_isEmpty,\n  domain_isSolved,\n  domain_toArr,\n  domain_toSmallest,\n  domain_toStr,\n  THROW,\n  getTerm,\n  TRIE_EMPTY,\n  TRIE_KEY_NOT_FOUND,\n  TRIE_NODE_SIZE,\n  trie_addNum,\n  trie_create,\n  trie_get,\n  trie_getNum,\n} from 'fdlib';\n\nimport { config_clone } from './config';\n\nlet space_uid = 0;\n\n/**\n * @returns {$space}\n */\nfunction space_createRoot() {\n  ASSERT(!(space_uid = 0));\n\n  if (process.env.NODE_ENV !== 'production') {\n    // Only for debugging\n    const _depth = 0;\n    const _child = 0;\n    const _path = '';\n    return space_createNew([], undefined, _depth, _child, _path);\n  }\n\n  return space_createNew([]);\n}\n\n/**\n * @param {$config} config\n * @returns {$space}\n */\nfunction space_createFromConfig(config) {\n  ASSERT(config._class === '$config', 'EXPECTING_CONFIG');\n\n  const space = space_createRoot();\n  space_initFromConfig(space, config);\n  return space;\n}\n\n/**\n * Create a space node that is a child of given space node\n *\n * @param {$space} space\n * @returns {$space}\n */\nfunction space_createClone(space) {\n  ASSERT(space._class === '$space', 'SPACE_SHOULD_BE_SPACE');\n\n  const vardomsCopy = space.vardoms.slice(0);\n  const unsolvedVarIndexes = space._unsolved.slice(0);\n\n  if (process.env.NODE_ENV !== 'production') {\n    // Only for debugging\n    const _depth = space._depth + 1;\n    const _child = space._child_count++;\n    const { _path } = space;\n    return space_createNew(\n      vardomsCopy,\n      unsolvedVarIndexes,\n      _depth,\n      _child,\n      _path\n    );\n  }\n\n  return space_createNew(vardomsCopy, unsolvedVarIndexes);\n}\n\n/**\n * Create a new config with the configuration of the given Space\n * Basically clones its config but updates the `initialDomains` with fresh state\n *\n * @param {$space} space\n * @param {$config} config\n * @returns {$space}\n */\nfunction space_toConfig(space, config) {\n  ASSERT(space._class === '$space', 'SPACE_SHOULD_BE_SPACE');\n  ASSERT(config._class === '$config', 'EXPECTING_CONFIG');\n\n  const { vardoms } = space;\n  const { allVarNames } = config;\n  const newDomains = [];\n  for (let i = 0, n = allVarNames.length; i < n; i++) {\n    const domain = vardoms[i];\n    newDomains[i] = domain_toStr(domain);\n  }\n\n  return config_clone(config, undefined, newDomains);\n}\n\n/**\n * Concept of a space that holds config, some named domains (referred to as \"vars\"), and some propagators\n *\n * @param {$domain[]} vardoms Maps 1:1 to config.allVarNames\n * @param {number[]|undefined} unsolvedVarIndexes\n * @param {number} _depth (Debugging only) How many parent nodes are there from this node?\n * @param {number} _child (Debugging only) How manieth child is this of the parent?\n * @param {string} _path (Debugging only) String of _child values from root to this node (should be unique per node and len=_depth+1)\n * @returns {$space}\n */\nfunction space_createNew(vardoms, unsolvedVarIndexes, _depth, _child, _path) {\n  ASSERT(\n    typeof vardoms === 'object' && vardoms,\n    'vars should be an object',\n    vardoms\n  );\n\n  const space = {\n    _class: '$space',\n\n    vardoms,\n    _unsolved: unsolvedVarIndexes,\n\n    next_distribution_choice: 0,\n    updatedVarIndex: -1, // The varIndex that was updated when creating this space (-1 for root)\n    _lastChosenValue: -1, // Cache to prevent duplicate operations\n  };\n\n  // Search graph metrics (debug only)\n  if (process.env.NODE_ENV !== 'production') {\n    space._depth = _depth;\n    space._child = _child;\n    space._child_count = 0;\n    space._path = _path + _child;\n    space._uid = ++space_uid;\n  }\n\n  return space;\n}\n\n/**\n * @param {$space} space\n * @param {$config} config\n */\nfunction space_initFromConfig(space, config) {\n  ASSERT(space._class === '$space', 'EXPECTING_SPACE');\n  ASSERT(config._class === '$config', 'EXPECTING_CONFIG');\n\n  space_generateVars(space, config); // Config must be initialized (generating propas may introduce fresh vars)\n  space_initializeUnsolvedVars(space, config);\n}\n\n/**\n * Return the current number of unsolved vars for given space.\n * This is only used for testing, prevents leaking internals into tests\n *\n * @param {$space} space\n * @param {$config} config\n * @returns {number}\n */\nfunction space_getUnsolvedVarCount(space, config) {\n  ASSERT(space._class === '$space', 'EXPECTING_SPACE');\n  ASSERT(config._class === '$config', 'EXPECTING_CONFIG');\n\n  return space._unsolved.length;\n}\n\n/**\n * Only use this for testing or debugging as it creates a fresh array\n * for the result. We don't use the names internally, anyways.\n *\n * @param {$space} space\n * @param {$config} config\n * @returns {string[]} var names of all unsolved vars of given space\n */\nfunction _space_getUnsolvedVarNamesFresh(space, config) {\n  ASSERT(space._class === '$space', 'EXPECTING_SPACE');\n  ASSERT(config._class === '$config', 'EXPECTING_CONFIG');\n\n  return space._unsolved.map(varIndex => config.allVarNames[varIndex]);\n}\n\n/**\n * Initialized the list of unsolved variables. These are either the explicitly\n * targeted variables, or any unsolved variables if none were explicitly targeted.\n *\n * @param {$space} space\n * @param {$config} config\n */\nfunction space_initializeUnsolvedVars(space, config) {\n  ASSERT(space._class === '$space', 'EXPECTING_SPACE');\n  ASSERT(config._class === '$config', 'EXPECTING_CONFIG');\n\n  const targetVarNames = config.targetedVars;\n  const { vardoms } = space;\n\n  const unsolvedVarIndexes = [];\n  space._unsolved = unsolvedVarIndexes;\n\n  if (targetVarNames === 'all') {\n    for (let varIndex = 0, n = vardoms.length; varIndex < n; ++varIndex) {\n      if (!domain_isSolved(vardoms[varIndex])) {\n        if (\n          config._varToPropagators[varIndex] ||\n          (config._constrainedAway &&\n            config._constrainedAway.indexOf(varIndex) >= 0)\n        ) {\n          unsolvedVarIndexes.push(varIndex);\n        }\n      }\n    }\n  } else {\n    ASSERT(\n      Array.isArray(targetVarNames),\n      'expecting targetVarNames to be an array or the string `all`',\n      targetVarNames\n    );\n    ASSERT(\n      targetVarNames.every(e => typeof e === 'string'),\n      'you must target var names only, they must all be strings',\n      targetVarNames\n    );\n    const varNamesTrie = config._varNamesTrie;\n    for (const varName of targetVarNames) {\n      space_addVarNameToUnsolved(\n        varName,\n        varNamesTrie,\n        vardoms,\n        unsolvedVarIndexes\n      );\n    }\n  }\n}\n\n/**\n * @param {string} varName\n * @param {$trie} varNamesTrie\n * @param {$nordom[]} vardoms\n * @param {number[]} unsolvedVarIndexes\n */\nfunction space_addVarNameToUnsolved(\n  varName,\n  varNamesTrie,\n  vardoms,\n  unsolvedVarIndexes\n) {\n  const varIndex = trie_get(varNamesTrie, varName);\n  if (varIndex === TRIE_KEY_NOT_FOUND)\n    THROW('E_VARS_SHOULD_EXIST_NOW [' + varName + ']');\n  if (!domain_isSolved(vardoms[varIndex])) {\n    unsolvedVarIndexes.push(varIndex);\n  }\n}\n\n/**\n * Run all the propagators until stability point.\n * Returns true if any propagator rejects.\n *\n * @param {$space} space\n * @param {$config} config\n * @returns {boolean} when true, a propagator rejects and the (current path to a) solution is invalid\n */\nfunction space_propagate(space, config) {\n  ASSERT_LOG(LOG_FLAG_PROPSTEPS, log => log('space_propagate()'));\n\n  ASSERT(space._class === '$space', 'EXPECTING_SPACE');\n  ASSERT(config._class === '$config', 'EXPECTING_CONFIG');\n  if (process.env.NODE_ENV !== 'production') {\n    config._propagates = (config._propagates | 0) + 1;\n  }\n\n  if (space_onBeforePropagate(space, config)) {\n    return true;\n  }\n\n  const propagators = config._propagators;\n\n  // \"cycle\" is one step, \"epoch\" all steps until stable (but not solved per se)\n\n  // worst case all unsolved vars change. but in general it's about 30% so run with that\n  const cells = Math.ceil(space._unsolved.length * TRIE_NODE_SIZE * 0.3);\n  const changedTrie = trie_create(TRIE_EMPTY, cells); // Track changed vars per cycle in this epoch\n  let cycles = 0;\n\n  ASSERT(typeof cycles === 'number', 'cycles is a number?');\n  ASSERT(changedTrie._class === '$trie', 'trie is a trie?');\n\n  let changedVars = []; // In one cycle\n\n  let minimal = 1;\n  if (space.updatedVarIndex >= 0) {\n    changedVars.push(space.updatedVarIndex);\n  } else {\n    // Very first cycle of first epoch of the search. all propagators must be visited at least once now.\n    const rejected = space_propagateAll(\n      space,\n      config,\n      propagators,\n      changedVars,\n      changedTrie,\n      ++cycles\n    );\n    if (rejected) {\n      return true;\n    }\n  }\n\n  while (changedVars.length) {\n    const newChangedVars = [];\n    const rejected = space_propagateChanges(\n      space,\n      config,\n      propagators,\n      minimal,\n      changedVars,\n      newChangedVars,\n      changedTrie,\n      ++cycles\n    );\n    if (rejected) {\n      return true;\n    }\n\n    changedVars = newChangedVars;\n    minimal = 2; // See space_propagateChanges\n  }\n\n  if (space_onAfterPropagate(space, config)) {\n    return true;\n  }\n\n  return false;\n}\n\nfunction space_propagateAll(\n  space,\n  config,\n  propagators,\n  changedVars,\n  changedTrie,\n  cycleIndex\n) {\n  ASSERT_LOG(LOG_FLAG_PROPSTEPS, log =>\n    log(\n      'space_propagateAll (' + propagators.length + ' propas have changed vars)'\n    )\n  );\n  for (const propagator of propagators) {\n    const rejected = space_propagateStep(\n      space,\n      config,\n      propagator,\n      changedVars,\n      changedTrie,\n      cycleIndex\n    );\n    if (rejected) return true;\n  }\n\n  return false;\n}\n\nfunction space_propagateByIndexes(\n  space,\n  config,\n  propagators,\n  propagatorIndexes,\n  changedVars,\n  changedTrie,\n  cycleIndex\n) {\n  ASSERT_LOG(LOG_FLAG_PROPSTEPS, log =>\n    log(\n      'space_propagateByIndexes (' +\n        propagatorIndexes.length +\n        ' propas have changed vars)'\n    )\n  );\n  for (let i = 0, n = propagatorIndexes.length; i < n; i++) {\n    const propagatorIndex = propagatorIndexes[i];\n    const propagator = propagators[propagatorIndex];\n    ASSERT_LOG(LOG_FLAG_PROPSTEPS, log =>\n      log(\n        ' - ',\n        i + 1 + '/' + propagatorIndexes.length,\n        '; prop index=',\n        propagatorIndex,\n        ', prop=',\n        JSON.stringify(propagator).replace(/\\n/g, '; ')\n      )\n    );\n    const rejected = space_propagateStep(\n      space,\n      config,\n      propagator,\n      changedVars,\n      changedTrie,\n      cycleIndex\n    );\n    if (rejected) {\n      ASSERT_LOG(LOG_FLAG_PROPSTEPS, log =>\n        log(' - ', i + 1 + '/' + propagatorIndexes.length, '; has rejected')\n      );\n      return true;\n    }\n  }\n\n  return false;\n}\n\nfunction space_propagateStep(\n  space,\n  config,\n  propagator,\n  changedVars,\n  changedTrie,\n  cycleIndex\n) {\n  ASSERT(propagator._class === '$propagator', 'EXPECTING_PROPAGATOR');\n\n  const { vardoms } = space;\n\n  const {\n    index1,\n    index2,\n    index3,\n    stepper,\n    arg1,\n    arg2,\n    arg3,\n    arg4,\n    arg5,\n    arg6,\n  } = propagator;\n\n  ASSERT(index1 !== 'undefined', 'all props at least use the first var...');\n  const domain1 = vardoms[index1];\n  const domain2 = index2 !== undefined && vardoms[index2];\n  const domain3 = index3 !== undefined && vardoms[index3];\n\n  ASSERT_NORDOM(domain1, true, domain__debug);\n  ASSERT(domain2 === undefined || ASSERT_NORDOM(domain2, true, domain__debug));\n  ASSERT(domain3 === undefined || ASSERT_NORDOM(domain3, true, domain__debug));\n\n  ASSERT(typeof stepper === 'function', 'stepper should be a func');\n  // TODO: if we can get a \"solved\" state here we can prevent an isSolved check later...\n  stepper(\n    space,\n    config,\n    index1,\n    index2,\n    index3,\n    arg1,\n    arg2,\n    arg3,\n    arg4,\n    arg5,\n    arg6\n  );\n\n  if (domain1 !== vardoms[index1]) {\n    if (domain_isEmpty(vardoms[index1])) {\n      return true; // Fail\n    }\n\n    space_recordChange(index1, changedTrie, changedVars, cycleIndex);\n  }\n\n  if (index2 !== undefined && domain2 !== vardoms[index2]) {\n    if (domain_isEmpty(vardoms[index2])) {\n      return true; // Fail\n    }\n\n    space_recordChange(index2, changedTrie, changedVars, cycleIndex);\n  }\n\n  if (index3 !== undefined && index3 !== -1 && domain3 !== vardoms[index3]) {\n    if (domain_isEmpty(vardoms[index3])) {\n      return true; // Fail\n    }\n\n    space_recordChange(index3, changedTrie, changedVars, cycleIndex);\n  }\n\n  return false;\n}\n\nfunction space_recordChange(varIndex, changedTrie, changedVars, cycleIndex) {\n  if (typeof varIndex === 'number') {\n    const status = trie_getNum(changedTrie, varIndex);\n    if (status !== cycleIndex) {\n      changedVars.push(varIndex);\n      trie_addNum(changedTrie, varIndex, cycleIndex);\n    }\n  } else {\n    ASSERT(Array.isArray(varIndex), 'index1 is always used');\n    for (const index of varIndex) {\n      space_recordChange(index, changedTrie, changedVars, cycleIndex);\n    }\n  }\n}\n\nfunction space_propagateChanges(\n  space,\n  config,\n  allPropagators,\n  minimal,\n  targetVars,\n  changedVars,\n  changedTrie,\n  cycleIndex\n) {\n  ASSERT_LOG(LOG_FLAG_PROPSTEPS, log =>\n    log(\n      'space_propagateChanges (' +\n        targetVars.length +\n        ' vars to check), var indexes;',\n      targetVars.slice(0, 10) +\n        (targetVars.length > 10\n          ? '... and ' + (targetVars.length - 10) + ' more'\n          : '')\n    )\n  );\n  ASSERT(space._class === '$space', 'EXPECTING_SPACE');\n  ASSERT(config._class === '$config', 'EXPECTING_CONFIG');\n\n  const { _varToPropagators: varToPropagators } = config;\n  for (let i = 0, vlen = targetVars.length; i < vlen; i++) {\n    const varIndex = targetVars[i];\n    const propagatorIndexes = varToPropagators[varIndex];\n    ASSERT_LOG(LOG_FLAG_PROPSTEPS, log =>\n      log(\n        ' - var ' + (i + 1) + '/' + targetVars.length,\n        ', varIndex',\n        targetVars[i],\n        ', is part of',\n        propagatorIndexes.length,\n        'propas;',\n        propagatorIndexes\n      )\n    );\n    // Note: the first loop of propagate() should require all propagators affected, even if\n    // it is just one. after that, if a var was updated that only has one propagator it can\n    // only have been updated by that one propagator. however, this step is queueing up\n    // propagators to check, again, since one of its vars changed. a propagator that runs\n    // twice without other changes will change nothing. so we do it for the initial loop,\n    // where the var is updated externally, after that the change can only occur from within\n    // a propagator so we skip it.\n    // ultimately a list of propagators should perform better but the indexOf negates that perf\n    // (this doesn't affect a whole lot of vars... most of them touch multiple propas)\n    if (propagatorIndexes && propagatorIndexes.length >= minimal) {\n      const result = space_propagateByIndexes(\n        space,\n        config,\n        allPropagators,\n        propagatorIndexes,\n        changedVars,\n        changedTrie,\n        cycleIndex\n      );\n      if (result) return true; // Rejected\n    }\n  }\n\n  return false;\n}\n\n/**\n * @param {$space} space\n * @param {$config} config\n * @returns {boolean}\n */\nfunction space_onBeforePropagate(space, config) {\n  const callback = config.beforeSpace;\n  if (callback && callback(space)) {\n    config.aborted = true;\n    return true;\n  }\n\n  return false;\n}\n\n/**\n * @param {$space} space\n * @param {$config} config\n * @returns {boolean}\n */\nfunction space_onAfterPropagate(space, config) {\n  const callback = config.afterSpace;\n  if (callback && callback(space)) {\n    config.aborted = true;\n    return true;\n  }\n\n  return false;\n}\n\n/**\n * Returns true if this space is solved - i.e. when\n * all the vars in the space have a singleton domain.\n *\n * This is a *very* strong condition that might not need\n * to be satisfied for a space to be considered to be\n * solved. For example, the propagators may determine\n * ranges for all variables under which all conditions\n * are met and there would be no further need to enumerate\n * those solutions.\n *\n * @param {$space} space\n * @param {$config} config\n * @returns {boolean}\n */\nfunction space_updateUnsolvedVarList(space, config) {\n  ASSERT(space._class === '$space', 'EXPECTING_SPACE');\n  ASSERT(config._class === '$config', 'EXPECTING_CONFIG');\n\n  const { vardoms } = space;\n  const unsolvedVarIndexes = space._unsolved;\n\n  let m = 0;\n  for (const varIndex of unsolvedVarIndexes) {\n    const domain = vardoms[varIndex];\n    if (!domain_isSolved(domain)) {\n      unsolvedVarIndexes[m++] = varIndex;\n    }\n  }\n\n  unsolvedVarIndexes.length = m;\n\n  return m === 0; // 0 unsolved means we've solved it :)\n}\n\n/**\n * Returns an object whose field names are the var names\n * and whose values are the solved values. The space *must*\n * be already in a solved state for this to work.\n *\n * @param {$space} space\n * @param {$config} config\n * @returns {Object}\n */\nfunction space_solution(space, config) {\n  ASSERT(space._class === '$space', 'EXPECTING_SPACE');\n  ASSERT(config._class === '$config', 'EXPECTING_CONFIG');\n\n  const { allVarNames } = config;\n  const result = {};\n  for (let varIndex = 0, n = allVarNames.length; varIndex < n; varIndex++) {\n    const varName = allVarNames[varIndex];\n    result[varName] = space_getVarSolveState(space, varIndex);\n  }\n\n  return result;\n}\n\n/**\n * Note: this is the (shared) second most called function of the library\n * (by a third of most, but still significantly more than the rest)\n *\n * @param {$space} space\n * @param {number} varIndex\n * @returns {number|number[]|boolean} The solve state for given var index, also put into result\n */\nfunction space_getVarSolveState(space, varIndex) {\n  ASSERT(typeof varIndex === 'number', 'VAR_SHOULD_BE_INDEX');\n  const domain = space.vardoms[varIndex];\n\n  if (domain_isEmpty(domain)) {\n    return false;\n  }\n\n  const value = domain_getValue(domain);\n  if (value !== NO_SUCH_VALUE) return value;\n\n  return domain_toArr(domain);\n}\n\nfunction space_getDomainArr(space, varIndex) {\n  return domain_toArr(space.vardoms[varIndex]);\n}\n\n/**\n * Initialize the vardoms array on the first space node.\n *\n * @param {$space} space\n * @param {$config} config\n */\nfunction space_generateVars(space, config) {\n  ASSERT(space._class === '$space', 'SPACE_SHOULD_BE_SPACE');\n  ASSERT(config._class === '$config', 'EXPECTING_CONFIG');\n\n  const { vardoms } = space;\n  ASSERT(vardoms, 'expecting var domains');\n  const { initialDomains } = config;\n  ASSERT(initialDomains, 'config should have initial vars');\n  const { allVarNames } = config;\n  ASSERT(allVarNames, 'config should have a list of vars');\n\n  for (let varIndex = 0, len = allVarNames.length; varIndex < len; varIndex++) {\n    const domain = initialDomains[varIndex];\n    ASSERT_NORDOM(domain, true, domain__debug);\n    vardoms[varIndex] = domain_toSmallest(domain);\n  }\n}\n\n/**\n * @param {$space} space\n * @param {$config} [config]\n * @param {boolean} [printPath]\n */\nfunction _space_debug(space, config, printPath) {\n  const term = getTerm();\n  term.log('\\n## Space:');\n  if (process.env.NODE_ENV !== 'production') {\n    term.log('# Meta:');\n    term.log('uid:', space._uid);\n    term.log('depth:', space._depth);\n    term.log('child:', space._child);\n    term.log('children:', space._child_count);\n    if (printPath) term.log('path:', space._path);\n  }\n\n  term.log('# Domains:');\n  term.log(\n    space.vardoms\n      .map(domain_toArr)\n      .map(\n        (d, i) =>\n          String(d).padEnd(15, ' ') +\n          (!config || config.allVarNames[i] === String(i)\n            ? ''\n            : ' (' + config.allVarNames[i] + ')')\n      )\n      .join('\\n')\n  );\n  term.log('##\\n');\n}\n\nexport {\n  space_createClone,\n  space_createFromConfig,\n  space_createRoot,\n  space_generateVars,\n  space_getDomainArr,\n  space_getVarSolveState,\n  space_initFromConfig,\n  space_propagate,\n  space_solution,\n  space_toConfig,\n  space_updateUnsolvedVarList,\n  // For testing\n  space_getUnsolvedVarCount,\n  _space_debug,\n  _space_getUnsolvedVarNamesFresh,\n};\n","import {\n  ASSERT,\n  ASSERT_NORDOM,\n  domain_max,\n  domain_min,\n  domain_size,\n  THROW,\n} from 'fdlib';\n\nconst BETTER = 1;\nconst SAME = 2;\nconst WORSE = 3;\n\n/**\n * Given a list of variables return the next var to consider based on the\n * current var distribution configuration and an optional filter condition.\n *\n * @param {$space} space\n * @param {$config} config\n * @return {number}\n */\nfunction distribution_getNextVarIndex(space, config) {\n  const { varStratConfig } = config;\n  const isBetterVarFunc = distribution_getFunc(varStratConfig.type);\n\n  const varIndex = _distribution_varFindBest(\n    space,\n    config,\n    isBetterVarFunc,\n    varStratConfig\n  );\n  return varIndex;\n}\n\n/**\n * @param {string} distName\n * @returns {Function|undefined}\n */\nfunction distribution_getFunc(distName) {\n  switch (distName) {\n    case 'naive':\n      return null;\n    case 'size':\n      return distribution_varByMinSize;\n    case 'min':\n      return distribution_varByMin;\n    case 'max':\n      return distribution_varByMax;\n    case 'markov':\n      return distribution_varByMarkov;\n    case 'list':\n      return distribution_varByList;\n    case 'throw':\n      return THROW('Throwing an error because var-strat requests it');\n    default:\n      return THROW('unknown next var func', distName);\n  }\n}\n\n/**\n * Return the best varIndex according to a fitness function\n *\n * @param {$space} space\n * @param {$config} config\n * @param {Function($space, currentIndex, bestIndex, Function)} [fitnessFunc] Given two var indexes returns true iif the first var is better than the second var\n * @param {Object} varStratConfig\n * @returns {number} The varIndex of the next var or NO_SUCH_VALUE\n */\nfunction _distribution_varFindBest(space, config, fitnessFunc, varStratConfig) {\n  let i = 0;\n  const unsolvedVarIndexes = space._unsolved;\n  ASSERT(\n    unsolvedVarIndexes.length,\n    'there should be unsolved vars left to pick (caller should ensure this)'\n  );\n\n  let bestVarIndex = unsolvedVarIndexes[i++];\n\n  if (fitnessFunc) {\n    for (let len = unsolvedVarIndexes.length; i < len; i++) {\n      const varIndex = unsolvedVarIndexes[i];\n      ASSERT(typeof varIndex === 'number', 'VAR_INDEX_SHOULD_BE_NUMBER');\n      ASSERT(\n        space.vardoms[varIndex] !== undefined,\n        'expecting each varIndex to have an domain',\n        varIndex\n      );\n\n      if (\n        BETTER ===\n        fitnessFunc(space, config, varIndex, bestVarIndex, varStratConfig)\n      ) {\n        bestVarIndex = varIndex;\n      }\n    }\n  }\n\n  ASSERT(typeof bestVarIndex === 'number', 'VAR_INDEX_SHOULD_BE_NUMBER');\n  ASSERT(bestVarIndex >= 0, 'VAR_INDEX_SHOULD_BE_POSITIVE');\n  return bestVarIndex;\n}\n\n// #####\n// preset fitness functions\n// #####\n\nfunction distribution_varByMinSize(space, config, varIndex1, varIndex2) {\n  ASSERT(space._class === '$space', 'SPACE_SHOULD_BE_SPACE');\n  ASSERT(typeof varIndex1 === 'number', 'INDEX_SHOULD_BE_NUMBER');\n  ASSERT(typeof varIndex2 === 'number', 'INDEX_SHOULD_BE_NUMBER');\n\n  const n =\n    domain_size(space.vardoms[varIndex1]) -\n    domain_size(space.vardoms[varIndex2]);\n  if (n < 0) return BETTER;\n  if (n > 0) return WORSE;\n  return SAME;\n}\n\nfunction distribution_varByMin(space, config, varIndex1, varIndex2) {\n  ASSERT(space._class === '$space', 'SPACE_SHOULD_BE_SPACE');\n  ASSERT(typeof varIndex1 === 'number', 'INDEX_SHOULD_BE_NUMBER');\n  ASSERT(typeof varIndex2 === 'number', 'INDEX_SHOULD_BE_NUMBER');\n  ASSERT_NORDOM(space.vardoms[varIndex1]);\n  ASSERT_NORDOM(space.vardoms[varIndex2]);\n  ASSERT(\n    space.vardoms[varIndex1] && space.vardoms[varIndex2],\n    'EXPECTING_NON_EMPTY'\n  );\n\n  const n =\n    domain_min(space.vardoms[varIndex1]) - domain_min(space.vardoms[varIndex2]);\n  if (n < 0) return BETTER;\n  if (n > 0) return WORSE;\n  return SAME;\n}\n\nfunction distribution_varByMax(space, config, varIndex1, varIndex2) {\n  ASSERT(space._class === '$space', 'SPACE_SHOULD_BE_SPACE');\n  ASSERT(typeof varIndex1 === 'number', 'INDEX_SHOULD_BE_NUMBER');\n  ASSERT(typeof varIndex2 === 'number', 'INDEX_SHOULD_BE_NUMBER');\n\n  const n =\n    domain_max(space.vardoms[varIndex1]) - domain_max(space.vardoms[varIndex2]);\n  if (n > 0) return BETTER;\n  if (n < 0) return WORSE;\n  return SAME;\n}\n\nfunction distribution_varByMarkov(\n  space,\n  config,\n  varIndex1,\n  varIndex2,\n  varStratConfig\n) {\n  ASSERT(space._class === '$space', 'SPACE_SHOULD_BE_SPACE');\n  ASSERT(typeof varIndex1 === 'number', 'INDEX_SHOULD_BE_NUMBER');\n  ASSERT(typeof varIndex2 === 'number', 'INDEX_SHOULD_BE_NUMBER');\n\n  const distOptions = config.varDistOptions;\n\n  // V1 is only, but if so always, better than v2 if v1 is a markov var\n\n  const varName1 = config.allVarNames[varIndex1];\n  ASSERT(typeof varName1 === 'string', 'VAR_NAME_SHOULD_BE_STRING');\n  if (distOptions[varName1] && distOptions[varName1].valtype === 'markov') {\n    return BETTER;\n  }\n\n  const varName2 = config.allVarNames[varIndex2];\n  ASSERT(typeof varName2 === 'string', 'VAR_NAME_SHOULD_BE_STRING');\n  if (distOptions[varName2] && distOptions[varName2].valtype === 'markov') {\n    return WORSE;\n  }\n\n  return distribution_varFallback(\n    space,\n    config,\n    varIndex1,\n    varIndex2,\n    varStratConfig.fallback\n  );\n}\n\nfunction distribution_varByList(\n  space,\n  config,\n  varIndex1,\n  varIndex2,\n  varStratConfig\n) {\n  ASSERT(space._class === '$space', 'SPACE_SHOULD_BE_SPACE');\n  ASSERT(typeof varIndex1 === 'number', 'INDEX_SHOULD_BE_NUMBER');\n  ASSERT(typeof varIndex2 === 'number', 'INDEX_SHOULD_BE_NUMBER');\n\n  // Note: config._priorityByIndex is compiled by FDO#prepare from given priorityByName\n  // if in the list, lowest prio can be 1. if not in the list, prio will be undefined\n  const hash = varStratConfig._priorityByIndex;\n\n  // If v1 or v2 is not in the list they will end up as undefined\n  const p1 = hash[varIndex1];\n  const p2 = hash[varIndex2];\n\n  ASSERT(p1 !== 0, 'SHOULD_NOT_USE_INDEX_ZERO');\n  ASSERT(p2 !== 0, 'SHOULD_NOT_USE_INDEX_ZERO');\n\n  if (!p1 && !p2) {\n    // Neither has a priority\n    return distribution_varFallback(\n      space,\n      config,\n      varIndex1,\n      varIndex2,\n      varStratConfig.fallback\n    );\n  }\n\n  // Invert this operation? (\"deprioritizing\").\n  const { inverted } = varStratConfig;\n\n  // If inverted being on the list makes it worse than not.\n\n  if (!p2) {\n    if (inverted) return WORSE;\n    return BETTER;\n  }\n\n  if (!p1) {\n    if (inverted) return BETTER;\n    return WORSE;\n  }\n\n  // The higher the p, the higher the prio. (the input array is compiled that way)\n  // if inverted then low p is higher prio\n\n  if (p1 > p2) {\n    if (inverted) return WORSE;\n    return BETTER;\n  }\n\n  ASSERT(p1 < p2, 'A_CANNOT_GET_SAME_INDEX_FOR_DIFFERENT_NAME');\n  if (inverted) return BETTER;\n  return WORSE;\n}\n\nfunction distribution_varFallback(\n  space,\n  config,\n  varIndex1,\n  varIndex2,\n  fallbackConfig\n) {\n  ASSERT(space._class === '$space', 'SPACE_SHOULD_BE_SPACE');\n  ASSERT(typeof varIndex1 === 'number', 'INDEX_SHOULD_BE_NUMBER');\n  ASSERT(typeof varIndex2 === 'number', 'INDEX_SHOULD_BE_NUMBER');\n\n  if (!fallbackConfig) {\n    return SAME;\n  }\n\n  const distName = fallbackConfig.type;\n  switch (distName) {\n    case 'size':\n      return distribution_varByMinSize(space, config, varIndex1, varIndex2);\n\n    case 'min':\n      return distribution_varByMin(space, config, varIndex1, varIndex2);\n\n    case 'max':\n      return distribution_varByMax(space, config, varIndex1, varIndex2);\n\n    case 'markov':\n      return distribution_varByMarkov(\n        space,\n        config,\n        varIndex1,\n        varIndex2,\n        fallbackConfig\n      );\n\n    case 'list':\n      return distribution_varByList(\n        space,\n        config,\n        varIndex1,\n        varIndex2,\n        fallbackConfig\n      );\n\n    case 'throw':\n      return THROW('nope');\n\n    default:\n      return THROW(`Unknown var dist fallback name: ${distName}`);\n  }\n}\n\nexport {\n  distribution_getNextVarIndex,\n  BETTER,\n  SAME,\n  WORSE,\n  // For testing\n  distribution_varByList,\n  distribution_varByMax,\n  distribution_varByMarkov,\n  distribution_varByMin,\n  distribution_varByMinSize,\n  distribution_varFallback,\n};\n","/*\nMarkov Distribution Helpers\n======================================================================\n\nHelpers for Markov-style probabilistic value & var distributions.\n\nconst markov = {\n  legend: ['small', 'med', 'large'],\n  matrix: [{\n    vector: [.5, 1, 1],\n    condition: function (S, varId) {\n      var prev = S.readMatrix(varId, S.cursor() - 1)\n      return S.isEqual(prev, 'small');\n    },\n  }, {\n    vector: [1, 1, 1],\n    condition: function () { return true; },\n  },\n  ],\n};\n\nconst markov = {\n  legend: ['small', 'med', 'large'],\n  matrix: [{\n    vector: [.5, 1, 1],\n    condition: function (S, varId) {\n      var prev = S.readMatrix(varId, S.cursor() - 1);\n      var result = {\n        value: S.isEqual(prev, 'small'),\n        deps: ...,\n      };\n      return result;\n    },\n  }, {\n    vector: [1, 1, 1],\n    condition: function () { return true; },\n  }],\n};\n\nInhomogenous Markov chains [see](https://cw.fel.cvut.cz/wiki/_media/courses/a6m33bin/markov-chains-2.pdf)\n\nin an inhomogeneous Markov model, we can have different distributions at different positions in the sequence\n\nhttps://en.wikipedia.org/wiki/Markov_chain#Music\n\n*/\n\nimport { ASSERT, domain_containsValue } from 'fdlib';\n\n/**\n * Given a domain, probability vector, value legend, and rng\n * function; return one of the values in the value legend\n * according to the outcome of the rng and considering the\n * prob weight of each value in the legend.\n * The rng should be normalized (returning values from 0 including\n * up to but not including 1), unless the argument says otherwise\n * (that is used for testing only, to get around rounding errors).\n *\n * @param {$domain} domain A regular domain. It's values only determine whether a legend value can be used, it may have values that can never be picked. It's only a filter mask.\n * @param {number[]} probVector List of probabilities, maps 1:1 to val_legend.\n * @param {number[]} valLegend List of values eligible for picking. Maps 1:1 to prob_vector. Only values in the current domain are actually eligible.\n * @param {Function} randomFunc\n * @param {boolean} [rngIsNormalized=true] Is 0<=rng()<1 or 0<=rng()<total_prob ? The latter is only used for testing to avoid rounding errors.\n * @return {number | undefined}\n */\nfunction distribution_markovSampleNextFromDomain(\n  domain,\n  probVector,\n  valLegend,\n  randomFunc,\n  rngIsNormalized = true\n) {\n  ASSERT(Boolean(valLegend), 'A_SHOULD_HAVE_VAL_LEGEND');\n  ASSERT(\n    probVector.length <= valLegend.length,\n    'A_PROB_VECTOR_SIZE_SHOULD_BE_LTE_LEGEND'\n  );\n\n  // Make vector & legend for available values only\n  const filteredLegend = [];\n  const cumulativeFilteredProbVector = [];\n  let totalProb = 0;\n  for (let index = 0; index < probVector.length; index++) {\n    const prob = probVector[index];\n    if (prob > 0) {\n      const value = valLegend[index];\n      if (domain_containsValue(domain, value)) {\n        totalProb += prob;\n        cumulativeFilteredProbVector.push(totalProb);\n        filteredLegend.push(value);\n      }\n    }\n  }\n\n  // No more values left to search\n  if (cumulativeFilteredProbVector.length === 0) {\n    return;\n  }\n\n  // Only one value left\n  if (cumulativeFilteredProbVector.length === 1) {\n    return filteredLegend[0];\n  }\n\n  // TOFIX: could set `cumulativeFilteredProbVector[cumulativeFilteredProbVector.length-1] = 1` here...\n\n  return _distribution_markovRoll(\n    randomFunc,\n    totalProb,\n    cumulativeFilteredProbVector,\n    filteredLegend,\n    rngIsNormalized\n  );\n}\n\n/**\n * @private\n * @param {Function} rng A function (\"random number generator\"), which is usually normalized, but in tests may not be\n * @param {number} totalProb\n * @param {number[]} cumulativeProbVector Maps 1:1 to the value legend. `[prob0, prob0+prob1, prob0+prob1+prob2, etc]`\n * @param {number[]} valueLegend\n * @param {boolean} rngIsNormalized\n * @returns {number}\n */\nfunction _distribution_markovRoll(\n  rng,\n  totalProb,\n  cumulativeProbVector,\n  valueLegend,\n  rngIsNormalized\n) {\n  const rngRoll = rng();\n  let probVal = rngRoll;\n  if (rngIsNormalized) {\n    // 0 <= rng < 1\n    // roll should yield; 0<=value<1\n    ASSERT(rngRoll >= 0, 'RNG_SHOULD_BE_NORMALIZED');\n    ASSERT(rngRoll < 1, 'RNG_SHOULD_BE_NORMALIZED');\n    probVal = rngRoll * totalProb;\n  }\n  // Else 0 <= rng < totalProb (mostly to avoid precision problems in tests)\n\n  let index = 0;\n  for (\n    const probVectorCount = cumulativeProbVector.length;\n    index < probVectorCount;\n    index++\n  ) {\n    // Note: if first element is 0.1 and roll is 0.1 this will pick the\n    // SECOND item. by design. so prob domains are `[x, y)`\n    const prob = cumulativeProbVector[index];\n    if (prob > probVal) {\n      break;\n    }\n  }\n\n  return valueLegend[index];\n}\n\nexport { distribution_markovSampleNextFromDomain };\n","/*\nThe functions in this file are supposed to determine the next\nvalue while solving a Space. The functions are supposed to\nreturn the new domain for some given var index. If there's no\nnew choice left it should return undefined to signify the end.\n*/\n\nimport {\n  ASSERT,\n  ASSERT_LOG,\n  ASSERT_NORDOM,\n  LOG_FLAG_CHOICE,\n  NO_SUCH_VALUE,\n  domain__debug,\n  domain_containsValue,\n  domain_createValue,\n  domain_createRange,\n  domain_getFirstIntersectingValue,\n  domain_intersection,\n  domain_isSolved,\n  domain_max,\n  domain_middleElement,\n  domain_min,\n  domain_removeValue,\n  THROW,\n} from 'fdlib';\n\nimport { markov_createLegend, markov_createProbVector } from '../markov';\nimport { distribution_markovSampleNextFromDomain } from './markov';\n\nconst FIRST_CHOICE = 0;\nconst SECOND_CHOICE = 1;\nconst THIRD_CHOICE = 2;\nconst NO_CHOICE = undefined;\n\nfunction distribute_getNextDomainForVar(space, config, varIndex, choiceIndex) {\n  ASSERT(space._class === '$space', 'SPACE_SHOULD_BE_SPACE');\n  ASSERT(config._class === '$config', 'EXPECTING_CONFIG');\n  ASSERT(typeof varIndex === 'number', 'VAR_INDEX_SHOULD_BE_NUMBER');\n  ASSERT(\n    space.vardoms[varIndex] && !domain_isSolved(space.vardoms[varIndex]),\n    'CALLSITE_SHOULD_PREVENT_DETERMINED'\n  ); // TODO: test\n\n  let valueStrategy = config.valueStratName;\n\n  // Each var can override the value distributor\n  const configVarDistOptions = config.varDistOptions;\n  const varName = config.allVarNames[varIndex];\n  ASSERT(typeof varName === 'string', 'VAR_NAME_SHOULD_BE_STRING');\n  const valueDistributorName =\n    configVarDistOptions[varName] && configVarDistOptions[varName].valtype;\n  if (valueDistributorName) valueStrategy = valueDistributorName;\n\n  const domain =\n    typeof valueStrategy === 'function'\n      ? valueStrategy(space, varIndex, choiceIndex)\n      : _distribute_getNextDomainForVar(\n          valueStrategy,\n          space,\n          config,\n          varIndex,\n          choiceIndex\n        );\n  ASSERT_LOG(LOG_FLAG_CHOICE, log =>\n    log(\n      'distribute_getNextDomainForVar; index',\n      varIndex,\n      'is now',\n      domain__debug(domain)\n    )\n  );\n  return domain;\n}\n\nfunction _distribute_getNextDomainForVar(\n  stratName,\n  space,\n  config,\n  varIndex,\n  choiceIndex\n) {\n  ASSERT(space._class === '$space', 'EXPECTING_SPACE');\n  ASSERT(config._class === '$config', 'EXPECTING_CONFIG');\n\n  switch (stratName) {\n    case 'max':\n      return distribution_valueByMax(space, varIndex, choiceIndex);\n\n    case 'markov':\n      return distribution_valueByMarkov(space, config, varIndex, choiceIndex);\n\n    case 'mid':\n      return distribution_valueByMid(space, varIndex, choiceIndex);\n\n    case 'min':\n    case 'naive':\n      return distribution_valueByMin(space, varIndex, choiceIndex);\n\n    case 'minMaxCycle':\n      return distribution_valueByMinMaxCycle(space, varIndex, choiceIndex);\n\n    case 'list':\n      return distribution_valueByList(space, config, varIndex, choiceIndex);\n\n    case 'splitMax':\n      return distribution_valueBySplitMax(space, varIndex, choiceIndex);\n\n    case 'splitMin':\n      return distribution_valueBySplitMin(space, varIndex, choiceIndex);\n\n    case 'throw':\n      return THROW('Throwing an error because val-strat requests it');\n\n    default:\n      THROW('unknown next var func', stratName);\n  }\n}\n\n/**\n * Attempt to solve by setting var domain to values in the order\n * given as a list. This may also be a function which should\n * return a new domain given the space, var index, and choice index.\n *\n * @param {$space} space\n * @param {$config} config\n * @param {number} varIndex\n * @param {number} choiceIndex\n * @returns {$domain|undefined} The new domain for this var index in the next space TOFIX: support small domains\n */\nfunction distribution_valueByList(space, config, varIndex, choiceIndex) {\n  ASSERT_LOG(LOG_FLAG_CHOICE, log =>\n    log('distribution_valueByList', varIndex, choiceIndex)\n  );\n  ASSERT(space._class === '$space', 'SPACE_SHOULD_BE_SPACE');\n  ASSERT(config._class === '$config', 'EXPECTING_CONFIG');\n  ASSERT(typeof varIndex === 'number', 'VAR_INDEX_SHOULD_BE_NUMBER');\n  ASSERT(typeof choiceIndex === 'number', 'CHOICE_SHOULD_BE_NUMBER');\n\n  const domain = space.vardoms[varIndex];\n  const varName = config.allVarNames[varIndex];\n  ASSERT(typeof varName === 'string', 'VAR_NAME_SHOULD_BE_STRING');\n  ASSERT(domain && !domain_isSolved(domain), 'DOMAIN_SHOULD_BE_UNDETERMINED');\n\n  const configVarDistOptions = config.varDistOptions;\n  ASSERT(configVarDistOptions, 'space should have config.varDistOptions');\n  ASSERT(\n    configVarDistOptions[varName],\n    'there should be distribution options available for every var',\n    varName\n  );\n  ASSERT(\n    configVarDistOptions[varName].list,\n    'there should be a distribution list available for every var',\n    varName\n  );\n  const varDistOptions = configVarDistOptions[varName];\n  const listSource = varDistOptions.list;\n\n  let fallbackName = '';\n  if (varDistOptions.fallback) {\n    fallbackName = varDistOptions.fallback.valtype;\n    ASSERT(fallbackName, 'should have a fallback type');\n    ASSERT(fallbackName !== 'list', 'prevent recursion loops');\n  }\n\n  let list = listSource;\n  if (typeof listSource === 'function') {\n    // Note: callback should return the actual list\n    list = listSource(space, varName, choiceIndex);\n  }\n\n  switch (choiceIndex) {\n    case FIRST_CHOICE: {\n      const nextValue = domain_getFirstIntersectingValue(domain, list);\n      if (nextValue === NO_SUCH_VALUE) {\n        return _distribute_getNextDomainForVar(\n          fallbackName || 'naive',\n          space,\n          config,\n          varIndex,\n          FIRST_CHOICE\n        );\n      }\n\n      space._lastChosenValue = nextValue;\n\n      return domain_createValue(nextValue);\n    }\n\n    case SECOND_CHOICE:\n      if (space._lastChosenValue >= 0) {\n        return domain_removeValue(domain, space._lastChosenValue);\n      }\n\n      return _distribute_getNextDomainForVar(\n        fallbackName || 'naive',\n        space,\n        config,\n        varIndex,\n        SECOND_CHOICE\n      );\n\n    default:\n      ASSERT(choiceIndex === THIRD_CHOICE, 'SHOULD_NOT_CALL_MORE_THAN_THRICE');\n      return NO_CHOICE;\n  }\n}\n\n/**\n * Searches through a var's values from min to max.\n * For each value in the domain it first attempts just\n * that value, then attempts the domain without this value.\n *\n * @param {$space} space\n * @param {number} varIndex\n * @param {number} choiceIndex\n * @returns {$domain|undefined} The new domain this var index should get in the next space\n */\nfunction distribution_valueByMin(space, varIndex, choiceIndex) {\n  ASSERT_LOG(LOG_FLAG_CHOICE, log =>\n    log('distribution_valueByMin', varIndex, choiceIndex)\n  );\n  ASSERT(space._class === '$space', 'SPACE_SHOULD_BE_SPACE');\n  ASSERT(typeof varIndex === 'number', 'VAR_INDEX_SHOULD_BE_NUMBER');\n  ASSERT(typeof choiceIndex === 'number', 'CHOICE_SHOULD_BE_NUMBER');\n\n  const domain = space.vardoms[varIndex];\n  ASSERT_NORDOM(domain);\n  ASSERT(domain && !domain_isSolved(domain), 'DOMAIN_SHOULD_BE_UNDETERMINED');\n\n  switch (choiceIndex) {\n    case FIRST_CHOICE: {\n      const minValue = domain_min(domain);\n      space._lastChosenValue = minValue;\n      return domain_createValue(minValue);\n    }\n\n    case SECOND_CHOICE:\n      // Cannot lead to empty domain because lo can only be SUP if\n      // domain was solved and we assert it wasn't.\n      ASSERT(\n        space._lastChosenValue >= 0,\n        'first choice should set this property and it should at least be 0',\n        space._lastChosenValue\n      );\n      return domain_removeValue(domain, space._lastChosenValue);\n\n    default:\n      ASSERT(choiceIndex === THIRD_CHOICE, 'SHOULD_NOT_CALL_MORE_THAN_THRICE');\n      return NO_CHOICE;\n  }\n}\n\n/**\n * Searches through a var's values from max to min.\n * For each value in the domain it first attempts just\n * that value, then attempts the domain without this value.\n *\n * @param {$space} space\n * @param {number} varIndex\n * @param {number} choiceIndex\n * @returns {$domain|undefined} The new domain this var index should get in the next space\n */\nfunction distribution_valueByMax(space, varIndex, choiceIndex) {\n  ASSERT_LOG(LOG_FLAG_CHOICE, log =>\n    log('distribution_valueByMax', varIndex, choiceIndex)\n  );\n  ASSERT(space._class === '$space', 'SPACE_SHOULD_BE_SPACE');\n  ASSERT(typeof varIndex === 'number', 'VAR_INDEX_SHOULD_BE_NUMBER');\n  ASSERT(typeof choiceIndex === 'number', 'CHOICE_SHOULD_BE_NUMBER');\n\n  const domain = space.vardoms[varIndex];\n  ASSERT_NORDOM(domain);\n  ASSERT(domain && !domain_isSolved(domain), 'DOMAIN_SHOULD_BE_UNDETERMINED');\n\n  switch (choiceIndex) {\n    case FIRST_CHOICE: {\n      const maxValue = domain_max(domain);\n      space._lastChosenValue = maxValue;\n      return domain_createValue(maxValue);\n    }\n\n    case SECOND_CHOICE:\n      // Cannot lead to empty domain because hi can only be SUB if\n      // domain was solved and we assert it wasn't.\n\n      ASSERT(\n        space._lastChosenValue > 0,\n        'first choice should set this property and it should at least be 1',\n        space._lastChosenValue\n      );\n      return domain_removeValue(domain, space._lastChosenValue);\n\n    default:\n      ASSERT(choiceIndex === THIRD_CHOICE, 'SHOULD_NOT_CALL_MORE_THAN_THRICE');\n      return NO_CHOICE;\n  }\n}\n\n/**\n * Searches through a var's values by taking the middle value.\n * This version targets the value closest to `(max-min)/2`\n * For each value in the domain it first attempts just\n * that value, then attempts the domain without this value.\n *\n * @param {$space} space\n * @param {number} varIndex\n * @param {number} choiceIndex\n * @returns {$domain|undefined} The new domain this var index should get in the next space\n */\nfunction distribution_valueByMid(space, varIndex, choiceIndex) {\n  ASSERT_LOG(LOG_FLAG_CHOICE, log =>\n    log('distribution_valueByMid', varIndex, choiceIndex)\n  );\n  ASSERT(space._class === '$space', 'SPACE_SHOULD_BE_SPACE');\n  ASSERT(typeof varIndex === 'number', 'VAR_INDEX_SHOULD_BE_NUMBER');\n  ASSERT(typeof choiceIndex === 'number', 'CHOICE_SHOULD_BE_NUMBER');\n\n  const domain = space.vardoms[varIndex];\n  ASSERT_NORDOM(domain);\n  ASSERT(domain && !domain_isSolved(domain), 'DOMAIN_SHOULD_BE_UNDETERMINED');\n\n  switch (choiceIndex) {\n    case FIRST_CHOICE: {\n      const middle = domain_middleElement(domain);\n      space._lastChosenValue = middle;\n      return domain_createValue(middle);\n    }\n\n    case SECOND_CHOICE:\n      ASSERT(\n        space._lastChosenValue >= 0,\n        'first choice should set this property and it should at least be 0',\n        space._lastChosenValue\n      );\n      return domain_removeValue(domain, space._lastChosenValue);\n\n    default:\n      ASSERT(choiceIndex === THIRD_CHOICE, 'SHOULD_NOT_CALL_MORE_THAN_THRICE');\n      return NO_CHOICE;\n  }\n}\n\n/**\n * Search a domain by splitting it up through the (max-min)/2 middle.\n * First simply tries the lower half, then tries the upper half.\n *\n * @param {$space} space\n * @param {number} varIndex\n * @param {number} choiceIndex\n * @returns {$domain|undefined} The new domain this var index should get in the next space\n */\nfunction distribution_valueBySplitMin(space, varIndex, choiceIndex) {\n  ASSERT_LOG(LOG_FLAG_CHOICE, log =>\n    log('distribution_valueBySplitMin', varIndex, choiceIndex)\n  );\n  ASSERT(space._class === '$space', 'SPACE_SHOULD_BE_SPACE');\n  ASSERT(typeof varIndex === 'number', 'VAR_INDEX_SHOULD_BE_NUMBER');\n  ASSERT(typeof choiceIndex === 'number', 'CHOICE_SHOULD_BE_NUMBER');\n\n  const domain = space.vardoms[varIndex];\n  ASSERT_NORDOM(domain);\n  ASSERT(domain && !domain_isSolved(domain), 'DOMAIN_SHOULD_BE_UNDETERMINED');\n\n  const max = domain_max(domain);\n\n  switch (choiceIndex) {\n    case FIRST_CHOICE: {\n      // TOFIX: can do this more optimal if coding it out explicitly\n      const min = domain_min(domain);\n      const mmhalf = min + Math.floor((max - min) / 2);\n      space._lastChosenValue = mmhalf;\n\n      // Note: domain is not determined so the operation cannot fail\n      // Note: this must do some form of intersect, though maybe not constrain\n      return domain_intersection(domain, domain_createRange(min, mmhalf));\n    }\n\n    case SECOND_CHOICE: {\n      ASSERT(\n        space._lastChosenValue >= 0,\n        'first choice should set this property and it should at least be 0',\n        space._lastChosenValue\n      );\n      // Note: domain is not determined so the operation cannot fail\n      // Note: this must do some form of intersect, though maybe not constrain\n      return domain_intersection(\n        domain,\n        domain_createRange(space._lastChosenValue + 1, max)\n      );\n    }\n\n    default:\n      ASSERT(choiceIndex === THIRD_CHOICE, 'SHOULD_NOT_CALL_MORE_THAN_THRICE');\n      return NO_CHOICE;\n  }\n}\n\n/**\n * Search a domain by splitting it up through the (max-min)/2 middle.\n * First simply tries the upper half, then tries the lower half.\n *\n * @param {$space} space\n * @param {number} varIndex\n * @param {number} choiceIndex\n * @returns {$domain|undefined} The new domain this var index should get in the next space\n */\nfunction distribution_valueBySplitMax(space, varIndex, choiceIndex) {\n  ASSERT_LOG(LOG_FLAG_CHOICE, log =>\n    log('distribution_valueBySplitMax', varIndex, choiceIndex)\n  );\n  ASSERT(space._class === '$space', 'SPACE_SHOULD_BE_SPACE');\n  ASSERT(typeof varIndex === 'number', 'VAR_INDEX_SHOULD_BE_NUMBER');\n  ASSERT(typeof choiceIndex === 'number', 'CHOICE_SHOULD_BE_NUMBER');\n\n  const domain = space.vardoms[varIndex];\n  ASSERT_NORDOM(domain);\n  ASSERT(domain && !domain_isSolved(domain), 'DOMAIN_SHOULD_BE_UNDETERMINED');\n\n  const min = domain_min(domain);\n\n  switch (choiceIndex) {\n    case FIRST_CHOICE: {\n      // TOFIX: can do this more optimal if coding it out explicitly\n      const max = domain_max(domain);\n      const mmhalf = min + Math.floor((max - min) / 2);\n      space._lastChosenValue = mmhalf;\n\n      // Note: domain is not determined so the operation cannot fail\n      // Note: this must do some form of intersect, though maybe not constrain\n      return domain_intersection(domain, domain_createRange(mmhalf + 1, max));\n    }\n\n    case SECOND_CHOICE: {\n      ASSERT(\n        space._lastChosenValue >= 0,\n        'first choice should set this property and it should at least be 0',\n        space._lastChosenValue\n      );\n      // Note: domain is not determined so the operation cannot fail\n      // Note: this must do some form of intersect, though maybe not constrain\n      return domain_intersection(\n        domain,\n        domain_createRange(min, space._lastChosenValue)\n      );\n    }\n\n    default:\n      ASSERT(choiceIndex === THIRD_CHOICE, 'SHOULD_NOT_CALL_MORE_THAN_THRICE');\n      return NO_CHOICE;\n  }\n}\n\n/**\n * Applies distribution_valueByMin and distribution_valueByMax alternatingly\n * depending on the position of the given var in the list of vars.\n *\n * @param {$space} space\n * @param {number} varIndex\n * @param {number} choiceIndex\n * @returns {$domain|undefined} The new domain this var index should get in the next space\n */\nfunction distribution_valueByMinMaxCycle(space, varIndex, choiceIndex) {\n  ASSERT_LOG(LOG_FLAG_CHOICE, log =>\n    log('distribution_valueByMinMaxCycle', varIndex, choiceIndex)\n  );\n  if (_isEven(varIndex)) {\n    return distribution_valueByMin(space, varIndex, choiceIndex);\n  }\n\n  return distribution_valueByMax(space, varIndex, choiceIndex);\n}\n\n/**\n * @param {number} n\n * @returns {boolean}\n */\nfunction _isEven(n) {\n  return n % 2 === 0;\n}\n\n/**\n * Search a domain by applying a markov chain to determine an optimal value\n * checking path.\n *\n * @param {$space} space\n * @param {$config} config\n * @param {number} varIndex\n * @param {number} choiceIndex\n * @returns {$domain|undefined} The new domain this var index should get in the next space\n */\nfunction distribution_valueByMarkov(space, config, varIndex, choiceIndex) {\n  ASSERT_LOG(LOG_FLAG_CHOICE, log =>\n    log('distribution_valueByMarkov', varIndex, choiceIndex)\n  );\n  ASSERT(space._class === '$space', 'SPACE_SHOULD_BE_SPACE');\n  ASSERT(typeof varIndex === 'number', 'VAR_INDEX_SHOULD_BE_NUMBER');\n  ASSERT(typeof choiceIndex === 'number', 'CHOICE_SHOULD_BE_NUMBER');\n\n  const domain = space.vardoms[varIndex];\n  ASSERT_NORDOM(domain);\n  ASSERT(domain && !domain_isSolved(domain), 'DOMAIN_SHOULD_BE_UNDETERMINED');\n\n  switch (choiceIndex) {\n    case FIRST_CHOICE: {\n      // THIS IS AN EXPENSIVE STEP!\n\n      const varName = config.allVarNames[varIndex];\n      ASSERT(typeof varName === 'string', 'VAR_NAME_SHOULD_BE_STRING');\n      const configVarDistOptions = config.varDistOptions;\n      ASSERT(configVarDistOptions, 'space should have config.varDistOptions');\n      const distOptions = configVarDistOptions[varName];\n      ASSERT(distOptions, 'markov vars should have  distribution options');\n      const { expandVectorsWith } = distOptions;\n      ASSERT(\n        distOptions.matrix,\n        'there should be a matrix available for every var'\n      );\n      ASSERT(\n        distOptions.legend ||\n          (typeof expandVectorsWith === 'number' && expandVectorsWith >= 0),\n        'every var should have a legend or expandVectorsWith set'\n      );\n\n      const random = distOptions.random || config._defaultRng;\n      ASSERT(typeof random === 'function', 'RNG_SHOULD_BE_FUNCTION');\n\n      // Note: expandVectorsWith can be 0, so check with null\n      const values = markov_createLegend(\n        typeof expandVectorsWith === 'number',\n        distOptions.legend,\n        domain\n      );\n      const valueCount = values.length;\n      if (!valueCount) {\n        return NO_CHOICE;\n      }\n\n      const probabilities = markov_createProbVector(\n        space,\n        distOptions.matrix,\n        expandVectorsWith,\n        valueCount\n      );\n      const value = distribution_markovSampleNextFromDomain(\n        domain,\n        probabilities,\n        values,\n        random\n      );\n      if (value === null) {\n        return NO_CHOICE;\n      }\n\n      ASSERT(\n        domain_containsValue(domain, value),\n        'markov picks a value from the existing domain so no need for a constrain below'\n      );\n      space._lastChosenValue = value;\n\n      return domain_createValue(value);\n    }\n\n    case SECOND_CHOICE: {\n      const lastValue = space._lastChosenValue;\n      ASSERT(\n        typeof lastValue === 'number',\n        'should have cached previous value'\n      );\n\n      const newDomain = domain_removeValue(domain, lastValue);\n      ASSERT(\n        domain,\n        'domain cannot be empty because only one value was removed and the domain is asserted to be not solved above'\n      );\n      ASSERT_NORDOM(newDomain, true, domain__debug);\n      return newDomain;\n    }\n\n    default:\n      ASSERT(choiceIndex === THIRD_CHOICE, 'SHOULD_NOT_CALL_MORE_THAN_THRICE');\n      return NO_CHOICE;\n  }\n}\n\nexport {\n  distribute_getNextDomainForVar,\n  FIRST_CHOICE,\n  SECOND_CHOICE,\n  THIRD_CHOICE,\n  NO_CHOICE,\n  // For testing:\n  distribution_valueByList,\n  distribution_valueByMarkov,\n  distribution_valueByMax,\n  distribution_valueByMid,\n  distribution_valueByMin,\n  distribution_valueByMinMaxCycle,\n  distribution_valueBySplitMax,\n  distribution_valueBySplitMin,\n  _distribute_getNextDomainForVar,\n};\n","import {\n  ASSERT,\n  ASSERT_LOG,\n  LOG_FLAG_SEARCH,\n  NO_SUCH_VALUE,\n  domain__debug,\n  domain_isSolved,\n} from 'fdlib';\n\nimport {\n  space_createClone,\n  space_propagate,\n  space_updateUnsolvedVarList,\n} from './space';\n\nimport { distribution_getNextVarIndex } from './distribution/var';\nimport { distribute_getNextDomainForVar } from './distribution/value';\n\n/**\n * Depth first search.\n *\n * Traverse the search space in DFS order and return the first (next) solution\n *\n * state.space must be the starting space. The object is used to store and\n * track continuation information from that point onwards.\n *\n * On return, state.status contains either 'solved' or 'end' to indicate\n * the status of the returned solution. Also state.more will be true if\n * the search can continue and there may be more solutions.\n *\n * @param {Object} state\n * @property {$space} state.space Root space if this is the start of searching\n * @property {boolean} [state.more] Are there spaces left to investigate after the last solve?\n * @property {$space[]} [state.stack]=[state,space] The search stack as initialized by this class\n * @property {string} [state.status] Set to 'solved' or 'end'\n * @param {$config} config\n * @param {Function} [dbgCallback] Call after each epoch until it returns false, then stop calling it.\n */\nfunction search_depthFirst(state, config, dbgCallback) {\n  let { stack } = state;\n  let epochs = 0;\n\n  // The stack only contains stable spaces. the first space is not\n  // stable so we propagate it first and before putting it on the stack.\n  const isStart = !stack || stack.length === 0;\n  if (isStart) {\n    if (!stack) {\n      state.stack = [];\n      stack = state.stack;\n    }\n\n    const solved = search_depthFirstLoop(state.space, config, stack, state);\n    if (dbgCallback && dbgCallback(++epochs)) dbgCallback = undefined;\n    if (solved) return;\n  }\n\n  while (stack.length > 0 && !config.aborted) {\n    ASSERT_LOG(LOG_FLAG_SEARCH, log => log(''));\n    ASSERT_LOG(LOG_FLAG_SEARCH, log => log(''));\n    // Take the top space and generate the next offspring, if any\n    const childSpace = search_createNextSpace(stack[stack.length - 1], config);\n    if (childSpace) {\n      // Stabilize the offspring and put it on the stack\n      const solved = search_depthFirstLoop(childSpace, config, stack, state);\n      if (dbgCallback && dbgCallback(++epochs)) dbgCallback = undefined;\n      if (solved) return;\n    } else {\n      // Remove the space, it has no more children. this is a dead end.\n      stack.pop();\n    }\n  }\n\n  // There are no more spaces to explore and therefor no further solutions to be found.\n  state.status = 'end';\n  state.more = false;\n}\n\n/**\n * One search step of the given space\n *\n * @param {$space} space\n * @param {$config} config\n * @param {$space[]} stack\n * @param {Object} state See search_depthFirst\n * @returns {boolean}\n */\nfunction search_depthFirstLoop(space, config, stack, state) {\n  ASSERT_LOG(LOG_FLAG_SEARCH, log => log('search_depthFirstLoop; next space'));\n  ASSERT_LOG(LOG_FLAG_SEARCH, log =>\n    log(\n      '  -',\n      Math.min(10, space.vardoms.length) + '/' + space.vardoms.length,\n      'domains:',\n      space.vardoms\n        .slice(0, 10)\n        .map(domain__debug)\n        .join(', ')\n    )\n  );\n  ASSERT_LOG(LOG_FLAG_SEARCH, log =>\n    log(\n      '  - updated var index:',\n      space.updatedVarIndex < 0\n        ? 'root space so check all'\n        : space.updatedVarIndex\n    )\n  );\n  const rejected = space_propagate(space, config);\n  ASSERT_LOG(LOG_FLAG_SEARCH, log =>\n    log('search_depthFirstLoop; did space_propagate reject?', rejected)\n  );\n\n  if (rejected) {\n    ASSERT_LOG(LOG_FLAG_SEARCH, log => log(' ##  REJECTED'));\n    if (config.aborted) {\n      ASSERT_LOG(LOG_FLAG_SEARCH, log => log(' ##  (ABORTED BY CALLBACK)'));\n    }\n  }\n\n  return search_afterPropagation(rejected, space, config, stack, state);\n}\n\n/**\n * Process a propagated space and the result. If it rejects, discard the\n * space. If it passed, act accordingly. Otherwise determine whether the\n * space has children. If so queue them. Otherwise discard the space.\n *\n * @param {boolean} rejected Did the propagation end due to a rejection?\n * @param {$space} space\n * @param {$config} config\n * @param {$space[]} stack\n * @param {Object} state See search_depthFirst\n * @returns {boolean|undefined}\n */\nfunction search_afterPropagation(rejected, space, config, stack, state) {\n  if (rejected) {\n    space.failed = true;\n    return false;\n  }\n\n  const solved = space_updateUnsolvedVarList(space, config);\n  if (solved) {\n    _search_onSolve(state, space, stack);\n    return true;\n  }\n\n  // Put on the stack so the next loop can branch off it\n  stack.push(space);\n\n  return undefined; // Neither solved nor rejected\n}\n\n/**\n * Create a new Space based on given Space which basically\n * serves as a child node in a search graph. The space is\n * cloned and in the clone one variable is restricted\n * slightly further. This clone is then returned.\n * This takes various search and distribution strategies\n * into account.\n *\n * @param {$space} space\n * @param {$config} config\n * @returns {$space|undefined} a clone with small modification or nothing if this is an unsolved leaf node\n */\nfunction search_createNextSpace(space, config) {\n  const varIndex = distribution_getNextVarIndex(space, config);\n  ASSERT(typeof varIndex === 'number', 'VAR_INDEX_SHOULD_BE_NUMBER');\n  ASSERT(varIndex >= 0, 'VAR_INDEX_SHOULD_BE_POSITIVE');\n\n  if (varIndex !== NO_SUCH_VALUE) {\n    const domain = space.vardoms[varIndex];\n    if (!domain_isSolved(domain)) {\n      const choice = space.next_distribution_choice++;\n      const nextDomain = distribute_getNextDomainForVar(\n        space,\n        config,\n        varIndex,\n        choice\n      );\n      if (nextDomain) {\n        const clone = space_createClone(space);\n        clone.updatedVarIndex = varIndex;\n        clone.vardoms[varIndex] = nextDomain;\n        return clone;\n      }\n    }\n  }\n\n  // Space is an unsolved leaf node, return undefined\n}\n\n/**\n * When search finds a solution this function is called\n *\n * @param {Object} state The search state data\n * @param {Space} space The search node to fail\n * @param {Space[]} stack See state.stack\n */\nfunction _search_onSolve(state, space, stack) {\n  state.status = 'solved';\n  state.space = space; // Is this so the solution can be read from it?\n  state.more = stack.length > 0;\n}\n\nexport { search_afterPropagation, search_createNextSpace, search_depthFirst };\n","import {\n  ASSERT,\n  ASSERT_ARRDOM,\n  ASSERT_LOG,\n  ASSERT_VARDOMS_SLOW,\n  LOG_FLAG_SOLUTIONS,\n  LOG_MAX,\n  LOG_MIN,\n  LOG_NONE,\n  LOG_SOLVES,\n  LOG_STATS,\n  SUB,\n  SUP,\n  domain__debug,\n  domain_anyToSmallest,\n  domain_createEmpty,\n  domain_fromListToArrdom,\n  domain_isEmpty,\n  INSPECT,\n  THROW,\n  getTerm,\n  setTerm,\n  trie_get,\n} from 'fdlib';\n\nimport {\n  config_addConstraint,\n  config_addVarAnonConstant,\n  config_addVarDomain,\n  config_create,\n  config_init,\n  config_setOption,\n} from './config';\n\nimport { exporter, exporter_encodeVarName } from './exporter';\n\nimport { importer } from './importer';\n\nimport { search_depthFirst } from './search';\n\nimport {\n  space_createFromConfig,\n  space_solution,\n  space_toConfig,\n} from './space';\n\n/**\n * Finite Domain brute force solver Only\n * No input-problem optimizations applied, will try to solve the problem as is.\n *\n * @type {FDO}\n */\nclass FDO {\n  /**\n   * @param {Object} options = {}\n   * @property {string} [options.distribute='naive']\n   * @property {Object} [options.searchDefaults]\n   * @property {$config} [options.config=config_create()]\n   * @property {boolean} [options.exportBare]\n   * @property {number} [options.logging=LOG_NONE]\n   * @property {Object} [options.logger=console] An object like `console` that can override some of its methods\n   */\n  constructor(options = {}) {\n    this._class = 'fdo';\n    if (options.logger) setTerm(options.logger);\n    this.logging = options.log || LOG_NONE;\n    this.distribute = options.distribute || 'naive';\n    if (process.env.NODE_ENV !== 'production') {\n      if (options.exportBare !== undefined) {\n        this.GENERATE_BARE_DSL = options.exportBare || false;\n        this.exported = '';\n      }\n    }\n\n    ASSERT(\n      options._class !== '$config',\n      'config should be passed on in a config property of options'\n    );\n\n    if (options.config) {\n      this.config = options.config;\n      const { config } = this;\n      if (config.initialDomains) {\n        const { initialDomains } = config;\n        for (let i = 0, len = initialDomains.length; i < len; ++i) {\n          let domain = initialDomains[i];\n          if (domain.length === 0) domain = domain_createEmpty();\n          initialDomains[i] = domain_anyToSmallest(domain);\n        }\n      }\n\n      if (config._propagators) config._propagators = undefined; // Will be regenerated\n      if (config._varToPropagators) config._varToPropagators = undefined; // Will be regenerated\n    } else {\n      this.config = config_create();\n    }\n\n    this.solutions = [];\n\n    this.state = {\n      space: null,\n      more: false,\n    };\n\n    this._prepared = false;\n  }\n\n  /**\n   * Returns an anonymous var with given value as lo/hi for the domain\n   *\n   * @param {number} num\n   * @returns {string}\n   */\n  num(num) {\n    if (typeof num !== 'number') {\n      THROW(`FDO#num: expecting a number, got ${num} (a ${typeof num})`);\n    }\n\n    if (isNaN(num)) {\n      THROW('FDO#num: expecting a number, got NaN');\n    }\n\n    const varIndex = config_addVarAnonConstant(this.config, num);\n    if (process.env.NODE_ENV !== 'production') {\n      if (this.GENERATE_BARE_DSL) {\n        this.exported += ': __' + varIndex + '__ = ' + num + '\\n';\n      }\n    }\n\n    return this.config.allVarNames[varIndex];\n  }\n\n  /**\n   * Declare a var with optional given domain or constant value and distribution options.\n   *\n   * @param {string} [varName] Optional, Note that you can use this.num() to declare a constant.\n   * @param {$arrdom|number} [domainOrValue] Note: if number, it is a constant (so [domain,domain]) not a $numdom! If omitted it becomes [SUB, SUP]\n   * @param {Object} [distributionOptions] Var distribution options. A defined non-object here will throw an error to prevent doing declRange\n   * @param {boolean} [_allowEmpty=false] Temp (i hope) override for importer\n   * @param {boolean} [_override=false] Explicitly override the initial domain for an already existing var (for importer)\n   * @returns {string}\n   */\n  decl(varName, domainOrValue, distributionOptions, _allowEmpty, _override) {\n    if (varName === '') THROW('Var name can not be the empty string');\n    ASSERT(\n      varName === undefined || typeof varName === 'string',\n      'var name should be undefined or a string'\n    );\n    ASSERT(\n      distributionOptions === undefined ||\n        typeof distributionOptions === 'object',\n      'options must be omitted or an object'\n    );\n\n    const arrdom =\n      typeof domainOrValue === 'number'\n        ? [domainOrValue, domainOrValue]\n        : domainOrValue || [SUB, SUP];\n    ASSERT_ARRDOM(arrdom);\n\n    if (arrdom.length === 0 && !_allowEmpty) THROW('EMPTY_DOMAIN_NOT_ALLOWED');\n    const varIndex = config_addVarDomain(\n      this.config,\n      varName || true,\n      arrdom,\n      _allowEmpty,\n      _override\n    );\n    varName = this.config.allVarNames[varIndex];\n\n    if (distributionOptions) {\n      if (distributionOptions.distribute)\n        THROW('Use `valtype` to set the value distribution strategy');\n      config_setOption(\n        this.config,\n        'varValueStrat',\n        distributionOptions,\n        varName\n      );\n    }\n\n    if (process.env.NODE_ENV !== 'production') {\n      if (this.GENERATE_BARE_DSL) {\n        this.exported +=\n          ': ' + exporter_encodeVarName(varName) + ' = [' + arrdom + ']';\n        if (distributionOptions && distributionOptions.valtype === 'markov') {\n          this.exported += ' @markov';\n          if (distributionOptions.matrix) {\n            this.exported += ' matrix(' + distributionOptions.matrix + ')';\n          }\n\n          if (distributionOptions.expandVectorsWith !== undefined) {\n            this.exported +=\n              ' expand(' + distributionOptions.expandVectorsWith + ')';\n          }\n\n          if (distributionOptions.legend) {\n            this.exported += ' legend(' + distributionOptions.legend + ')';\n          }\n        }\n\n        this.exported +=\n          ' # options=' + JSON.stringify(distributionOptions) + '\\n';\n      }\n    }\n\n    return varName;\n  }\n\n  /**\n   * Declare multiple variables with the same domain/options\n   *\n   * @param {string[]} varNames\n   * @param {$arrdom|number} [domainOrValue] Note: if number, it is a constant (so [domain,domain]) not a $numdom! If omitted it becomes [SUB, SUP]\n   * @param {Object} [options] Var distribution options. A number here will throw an error to prevent doing declRange\n   */\n  decls(varNames, domainOrValue, options) {\n    for (let i = 0, n = varNames.length; i < n; ++i) {\n      this.decl(varNames[i], domainOrValue, options);\n    }\n  }\n\n  /**\n   * Declare a var with given range\n   *\n   * @param {string} varName\n   * @param {number} lo Ensure SUB<=lo<=hi<=SUP\n   * @param {number} hi Ensure SUB<=lo<=hi<=SUP\n   * @param {Object} [options] Var distribution options\n   */\n  declRange(varName, lo, hi, options) {\n    ASSERT(typeof lo === 'number', 'LO_SHOULD_BE_NUMBER');\n    ASSERT(typeof hi === 'number', 'HI_SHOULD_BE_NUMBER');\n    ASSERT(\n      typeof options === 'object' || options === undefined,\n      'EXPECTING_OPTIONS_OR_NOTHING'\n    );\n\n    return this.decl(varName, [lo, hi], options);\n  }\n\n  // Arithmetic Propagators\n\n  plus(A, B, C) {\n    const R = config_addConstraint(this.config, 'plus', [A, B, C]);\n    if (process.env.NODE_ENV !== 'production') {\n      if (this.GENERATE_BARE_DSL) {\n        this.exported +=\n          exporter_encodeVarName(R) +\n          ' = ' +\n          exporter_encodeVarName(A) +\n          ' + ' +\n          exporter_encodeVarName(B) +\n          ' # plus, result var was: ' +\n          C +\n          '\\n';\n      }\n    }\n\n    return R;\n  }\n\n  minus(A, B, C) {\n    const R = config_addConstraint(this.config, 'min', [A, B, C]);\n    if (process.env.NODE_ENV !== 'production') {\n      if (this.GENERATE_BARE_DSL) {\n        this.exported +=\n          exporter_encodeVarName(R) +\n          ' = ' +\n          exporter_encodeVarName(A) +\n          ' - ' +\n          exporter_encodeVarName(B) +\n          ' # min, result var was: ' +\n          C +\n          '\\n';\n      }\n    }\n\n    return R;\n  }\n\n  mul(A, B, C) {\n    const R = config_addConstraint(this.config, 'ring-mul', [A, B, C]);\n    if (process.env.NODE_ENV !== 'production') {\n      if (this.GENERATE_BARE_DSL) {\n        this.exported +=\n          exporter_encodeVarName(R) +\n          ' = ' +\n          exporter_encodeVarName(A) +\n          ' * ' +\n          exporter_encodeVarName(B) +\n          ' # ringmul, result var was: ' +\n          C +\n          '\\n';\n      }\n    }\n\n    return R;\n  }\n\n  div(A, B, C) {\n    const R = config_addConstraint(this.config, 'ring-div', [A, B, C]);\n    if (process.env.NODE_ENV !== 'production') {\n      if (this.GENERATE_BARE_DSL) {\n        this.exported +=\n          exporter_encodeVarName(R) +\n          ' = ' +\n          exporter_encodeVarName(A) +\n          ' / ' +\n          exporter_encodeVarName(B) +\n          ' # ringdiv, result var was: ' +\n          C +\n          '\\n';\n      }\n    }\n\n    return R;\n  }\n\n  sum(A, C) {\n    const R = config_addConstraint(this.config, 'sum', A, C);\n    if (process.env.NODE_ENV !== 'production') {\n      if (this.GENERATE_BARE_DSL) {\n        this.exported +=\n          exporter_encodeVarName(R) +\n          ' = sum(' +\n          A.map(exporter_encodeVarName) +\n          ') # result var was: ' +\n          C +\n          '\\n';\n      }\n    }\n\n    return R;\n  }\n\n  product(A, C) {\n    const R = config_addConstraint(this.config, 'product', A, C);\n    if (process.env.NODE_ENV !== 'production') {\n      if (this.GENERATE_BARE_DSL) {\n        this.exported +=\n          exporter_encodeVarName(R) +\n          ' = product(' +\n          A.map(exporter_encodeVarName) +\n          ') # result var was: ' +\n          C +\n          '\\n';\n      }\n    }\n\n    return R;\n  }\n\n  // TODO\n  // times_plus    k1*v1 + k2*v2\n  // wsum           k*v\n  // scale         k*v\n\n  // (In)equality Propagators\n  // only first expression can be array\n\n  distinct(A) {\n    if (process.env.NODE_ENV !== 'production') {\n      if (this.GENERATE_BARE_DSL) {\n        this.exported += 'distinct(' + A.map(exporter_encodeVarName) + ')\\n';\n      }\n    }\n\n    config_addConstraint(this.config, 'distinct', A);\n  }\n\n  eq(e1, e2) {\n    if (Array.isArray(e1)) {\n      for (let i = 0, n = e1.length; i < n; ++i) {\n        this.eq(e1[i], e2);\n      }\n    } else if (Array.isArray(e2)) {\n      for (let i = 0, n = e2.length; i < n; ++i) {\n        this.eq(e1, e2[i]);\n      }\n    } else {\n      if (process.env.NODE_ENV !== 'production') {\n        if (this.GENERATE_BARE_DSL) {\n          this.exported +=\n            exporter_encodeVarName(e1) +\n            ' == ' +\n            exporter_encodeVarName(e2) +\n            '\\n';\n        }\n      }\n\n      config_addConstraint(this.config, 'eq', [e1, e2]);\n    }\n  }\n\n  neq(e1, e2) {\n    if (Array.isArray(e1)) {\n      for (let i = 0, n = e1.length; i < n; ++i) {\n        this.neq(e1[i], e2);\n      }\n    } else if (Array.isArray(e2)) {\n      for (let i = 0, n = e2.length; i < n; ++i) {\n        this.neq(e1, e2[i]);\n      }\n    } else {\n      if (process.env.NODE_ENV !== 'production') {\n        if (this.GENERATE_BARE_DSL) {\n          this.exported +=\n            exporter_encodeVarName(e1) +\n            ' != ' +\n            exporter_encodeVarName(e2) +\n            '\\n';\n        }\n      }\n\n      config_addConstraint(this.config, 'neq', [e1, e2]);\n    }\n  }\n\n  gte(A, B) {\n    ASSERT(!Array.isArray(A), 'NOT_ACCEPTING_ARRAYS');\n    if (process.env.NODE_ENV !== 'production') {\n      if (this.GENERATE_BARE_DSL) {\n        this.exported +=\n          exporter_encodeVarName(A) + ' >= ' + exporter_encodeVarName(B) + '\\n';\n      }\n    }\n\n    config_addConstraint(this.config, 'gte', [A, B]);\n  }\n\n  lte(A, B) {\n    ASSERT(!Array.isArray(A), 'NOT_ACCEPTING_ARRAYS');\n    if (process.env.NODE_ENV !== 'production') {\n      if (this.GENERATE_BARE_DSL) {\n        this.exported +=\n          exporter_encodeVarName(A) + ' <= ' + exporter_encodeVarName(B) + '\\n';\n      }\n    }\n\n    config_addConstraint(this.config, 'lte', [A, B]);\n  }\n\n  gt(A, B) {\n    ASSERT(!Array.isArray(A), 'NOT_ACCEPTING_ARRAYS');\n    if (process.env.NODE_ENV !== 'production') {\n      if (this.GENERATE_BARE_DSL) {\n        this.exported +=\n          exporter_encodeVarName(A) + ' > ' + exporter_encodeVarName(B) + '\\n';\n      }\n    }\n\n    config_addConstraint(this.config, 'gt', [A, B]);\n  }\n\n  lt(A, B) {\n    ASSERT(!Array.isArray(A), 'NOT_ACCEPTING_ARRAYS');\n    if (process.env.NODE_ENV !== 'production') {\n      if (this.GENERATE_BARE_DSL) {\n        this.exported +=\n          exporter_encodeVarName(A) + ' < ' + exporter_encodeVarName(B) + '\\n';\n      }\n    }\n\n    config_addConstraint(this.config, 'lt', [A, B]);\n  }\n\n  isNeq(A, B, C) {\n    const R = config_addConstraint(this.config, 'reifier', [A, B, C], 'neq');\n    if (process.env.NODE_ENV !== 'production') {\n      if (this.GENERATE_BARE_DSL) {\n        this.exported +=\n          exporter_encodeVarName(R) +\n          ' = ' +\n          exporter_encodeVarName(A) +\n          ' !=? ' +\n          exporter_encodeVarName(B) +\n          '\\n';\n      }\n    }\n\n    return R;\n  }\n\n  isEq(A, B, C) {\n    const R = config_addConstraint(this.config, 'reifier', [A, B, C], 'eq');\n    if (process.env.NODE_ENV !== 'production') {\n      if (this.GENERATE_BARE_DSL) {\n        this.exported +=\n          exporter_encodeVarName(R) +\n          ' = ' +\n          exporter_encodeVarName(A) +\n          ' ==? ' +\n          exporter_encodeVarName(B) +\n          '\\n';\n      }\n    }\n\n    return R;\n  }\n\n  isGte(A, B, C) {\n    const R = config_addConstraint(this.config, 'reifier', [A, B, C], 'gte');\n    if (process.env.NODE_ENV !== 'production') {\n      if (this.GENERATE_BARE_DSL) {\n        this.exported +=\n          exporter_encodeVarName(R) +\n          ' = ' +\n          exporter_encodeVarName(A) +\n          ' >=? ' +\n          exporter_encodeVarName(B) +\n          '\\n';\n      }\n    }\n\n    return R;\n  }\n\n  isLte(A, B, C) {\n    const R = config_addConstraint(this.config, 'reifier', [A, B, C], 'lte');\n    if (process.env.NODE_ENV !== 'production') {\n      if (this.GENERATE_BARE_DSL) {\n        this.exported +=\n          exporter_encodeVarName(R) +\n          ' = ' +\n          exporter_encodeVarName(A) +\n          ' <=? ' +\n          exporter_encodeVarName(B) +\n          '\\n';\n      }\n    }\n\n    return R;\n  }\n\n  isGt(A, B, C) {\n    const R = config_addConstraint(this.config, 'reifier', [A, B, C], 'gt');\n    if (process.env.NODE_ENV !== 'production') {\n      if (this.GENERATE_BARE_DSL) {\n        this.exported +=\n          exporter_encodeVarName(R) +\n          ' = ' +\n          exporter_encodeVarName(A) +\n          ' >? ' +\n          exporter_encodeVarName(B) +\n          '\\n';\n      }\n    }\n\n    return R;\n  }\n\n  isLt(A, B, C) {\n    const R = config_addConstraint(this.config, 'reifier', [A, B, C], 'lt');\n    if (process.env.NODE_ENV !== 'production') {\n      if (this.GENERATE_BARE_DSL) {\n        this.exported +=\n          exporter_encodeVarName(R) +\n          ' = ' +\n          exporter_encodeVarName(A) +\n          ' <? ' +\n          exporter_encodeVarName(B) +\n          '\\n';\n      }\n    }\n\n    return R;\n  }\n\n  // Various rest\n\n  /**\n   * Solve this solver. It should be setup with all the constraints.\n   *\n   * @param {Object} options\n   * @property {number} [options.max=1000]\n   * @property {number} [options.log=this.logging] Logging level; one of: 0, 1 or 2 (see LOG_* constants)\n   * @property {string|Array.<string|Bvar>} options.vars Target branch vars or var names to force solve. Defaults to all.\n   * @property {string|Object} [options.distribute='naive'] Maps to FD.distribution.value, see config_setOptions\n   * @property {boolean} [_debug] A more human readable print of the configuration for this solver\n   * @property {boolean} [_debugConfig] Log out solver.config after prepare() but before run()\n   * @property {boolean} [_debugSpace] Log out solver._space after prepare() but before run(). Only works in dev code (stripped from dist)\n   * @property {boolean} [_debugSolver] Call solver._debugSolver() after prepare() but before run()\n   * @property {boolean} [_tostring] Serialize the config into a DSL\n   * @property {boolean} [_nosolve] Dont actually solve. Used for debugging when printing something but not interested in actually running.\n   * @property {number} [_debugDelay=0] When debugging, how many propagate steps should the debugging wait? (0 is only preprocessing)\n   * @returns {Object[]}\n   */\n  solve(options = {}) {\n    if (options.log) this.logging = options.log;\n    const log = this.logging;\n    const { max = 1000 } = options;\n\n    if (process.env.NODE_ENV !== 'production') {\n      if (this.GENERATE_BARE_DSL) {\n        getTerm().log(\n          '## bare export:\\n' + this.exported + '## end of exported\\n'\n        );\n      }\n    }\n\n    this._prepare(options, log);\n    let dbgCallback;\n    if (\n      options._tostring ||\n      options._debug ||\n      options._debugConfig ||\n      options._debugSpace ||\n      options._debugSolver\n    ) {\n      dbgCallback = epoch => {\n        if ((options._debugDelay | 0) >= epoch) {\n          if (options._tostring) getTerm().log(exporter(this.config));\n          if (options._debug) this._debugLegible();\n          if (options._debugConfig) this._debugConfig();\n          if (process.env.NODE_ENV !== 'production') {\n            if (options._debugSpace)\n              getTerm().log('## _debugSpace:\\n', INSPECT(this._space));\n          }\n\n          if (options._debugSolver) this._debugSolver();\n          return true;\n        }\n\n        return false;\n      };\n\n      if (dbgCallback(0)) dbgCallback = undefined;\n    }\n\n    if (options._nosolve) return;\n\n    this._run(max, log, dbgCallback);\n\n    return this.solutions;\n  }\n\n  /**\n   * Prepare internal configuration before actually solving\n   * Collects one-time config data and sets up defaults\n   *\n   * @param {Object} [options={}] See @solve\n   * @param {number} log One of the LOG_* constants\n   */\n  _prepare(options = {}, log) {\n    ASSERT(\n      log === undefined || (log >= LOG_MIN && log <= LOG_MAX),\n      'log level should be a valid value or be undefined (in tests)'\n    );\n    if (log >= LOG_STATS) {\n      getTerm().log('      - FD Preparing...');\n      getTerm().time('      - FD Prepare Time');\n    }\n\n    this._prepareConfig(options, log);\n\n    // Create the root node of the search tree (each node is a Space)\n    const rootSpace = space_createFromConfig(this.config);\n\n    if (process.env.NODE_ENV !== 'production') {\n      this._space = rootSpace; // Only exposed for easy access in tests, and so only available after .prepare()\n    }\n\n    this.state.space = rootSpace;\n    this.state.more = true;\n    this.state.stack = [];\n\n    this._prepared = true;\n    if (log >= LOG_STATS) getTerm().timeEnd('      - FD Prepare Time');\n  }\n\n  /**\n   * Prepare the config side of things for a solve.\n   * No space is created in this function (that's the point).\n   *\n   * @param {Object} options See _prepare\n   * @param {number} log\n   */\n  _prepareConfig(options, log) {\n    ASSERT(\n      log === undefined || (log >= LOG_MIN && log <= LOG_MAX),\n      'log level should be a valid value or be undefined (in tests)'\n    );\n\n    const { config } = this;\n    ASSERT_VARDOMS_SLOW(config.initialDomains, domain__debug);\n\n    if (options.vars && options.vars !== 'all') {\n      config_setOption(config, 'targeted_var_names', options.vars);\n    }\n\n    if (options.beforeSpace)\n      config_setOption(config, 'beforeSpace', options.beforeSpace);\n    if (options.afterSpace)\n      config_setOption(config, 'afterSpace', options.afterSpace);\n\n    config_init(config);\n  }\n\n  /**\n   * Run the solver. You should call @_prepare before calling this function.\n   *\n   * @param {number} max Hard stop the solver when this many solutions have been found\n   * @param {number} log One of the LOG_* constants\n   * @param {Function} [dbgCallback] Call after each epoch until it returns false, then stop calling it.\n   */\n  _run(max, log, dbgCallback) {\n    ASSERT(typeof max === 'number', 'max should be a number', max);\n    ASSERT(\n      log >= LOG_MIN && log <= LOG_MAX,\n      'log level should be a valid value'\n    );\n\n    ASSERT(this._prepared, 'must run #prepare before #run');\n    this._prepared = false;\n\n    const { state } = this;\n    ASSERT(state);\n\n    let term;\n    if (log >= LOG_STATS) {\n      term = getTerm();\n      term.log(`      - FD Var Count: ${this.config.allVarNames.length}`);\n      term.log(\n        `      - FD Targeted: ${\n          this.config.targetedVars === 'all'\n            ? 'all'\n            : this.config.targetedVars.length\n        }`\n      );\n      term.log(\n        `      - FD Constraint Count: ${this.config.allConstraints.length}`\n      );\n      term.log(\n        `      - FD Propagator Count: ${this.config._propagators.length}`\n      );\n      term.log('      - FD Solving...');\n      term.time('      - FD Solving Time');\n    }\n\n    let alreadyRejected = false;\n    const { vardoms } = state.space;\n    for (let i = 0, n = vardoms.length; i < n; ++i) {\n      if (domain_isEmpty(vardoms[i])) {\n        alreadyRejected = true;\n        if (log >= LOG_STATS) {\n          term.log(\n            '      - FD: rejected without propagation (' +\n              this.config.allVarNames[i] +\n              ' is empty)'\n          );\n        }\n\n        break;\n      }\n    }\n\n    let solvedSpaces;\n    if (alreadyRejected) {\n      if (log >= LOG_STATS) {\n        term.log('      - FD Input Problem Rejected Immediately');\n      }\n\n      solvedSpaces = [];\n    } else {\n      solvedSpaces = solver_runLoop(state, this.config, max, dbgCallback);\n    }\n\n    if (log >= LOG_STATS) {\n      term.timeEnd('      - FD Solving Time');\n      if (process.env.NODE_ENV !== 'production') {\n        term.log(\n          `      - FD debug stats: called propagate(): ${\n            this.config._propagates > 0\n              ? this.config._propagates + 'x'\n              : 'never! Finished by only using precomputations.'\n          }`\n        );\n      }\n\n      term.log(`      - FD Solutions: ${solvedSpaces.length}`);\n    }\n\n    solver_getSolutions(solvedSpaces, this.config, this.solutions, log);\n  }\n\n  hasVar(varName) {\n    return trie_get(this.config._varNamesTrie, varName) >= 0;\n  }\n\n  /**\n   * Sets the value distribution options for a var after declaring it.\n   *\n   * @param {string} varName\n   * @param {Object} options\n   */\n  setValueDistributionFor(varName, options) {\n    ASSERT(typeof varName === 'string', 'var name should be a string', varName);\n    ASSERT(\n      typeof options === 'object',\n      'value strat options should be an object'\n    );\n\n    config_setOption(this.config, 'varValueStrat', options, varName);\n    if (process.env.NODE_ENV !== 'production') {\n      if (this.GENERATE_BARE_DSL) {\n        this.exported =\n          this.exported.replace(\n            new RegExp('^(: ' + exporter_encodeVarName(varName) + ' =.*)', 'm'),\n            '$1 # markov (set below): ' + JSON.stringify(options)\n          ) +\n          '@custom set-valdist ' +\n          exporter_encodeVarName(varName) +\n          ' ' +\n          JSON.stringify(options) +\n          '\\n';\n      }\n    }\n  }\n\n  /**\n   * @returns {FDO}\n   */\n  branch_from_current_solution() {\n    // Get the _solved_ space, convert to config,\n    // use new config as base for new solver\n    const solvedConfig = space_toConfig(this.state.space, this.config);\n    return new FDO({ config: solvedConfig });\n  }\n\n  _debugLegible() {\n    const WITH_INDEX = true;\n    const clone = JSON.parse(JSON.stringify(this.config)); // Prefer this over config_clone, just in case.\n    const names = clone.allVarNames;\n    const targeted = clone.targetedVars;\n    const constraints = clone.allConstraints;\n    const domains = clone.initialDomains;\n    const propagators = clone._propagators;\n\n    for (const key in clone) {\n      // Underscored prefixed objects are generally auto-generated structs\n      // we don't want to debug a 5mb buffer, one byte per line.\n      if (key[0] === '_' && typeof clone[key] === 'object') {\n        clone[key] = '<removed>';\n      }\n    }\n\n    clone.allVarNames = '<removed>';\n    clone.allConstraints = '<removed>';\n    clone.initialDomains = '<removed>';\n    clone.varDistOptions = '<removed>';\n    if (targeted !== 'all') clone.targetedVars = '<removed>';\n\n    const term = getTerm();\n    term.log('\\n## _debug:\\n');\n    term.log('- config:');\n    term.log(INSPECT(clone));\n    term.log('- vars (' + names.length + '):');\n    term.log(\n      names\n        .map(\n          (name, index) =>\n            `${WITH_INDEX ? index : ''}: ${domain__debug(domains[index])} ${\n              name === String(index) ? '' : ' // ' + name\n            }`\n        )\n        .join('\\n')\n    );\n    if (targeted !== 'all') {\n      term.log(\n        '- targeted vars (' + targeted.length + '): ' + targeted.join(', ')\n      );\n    }\n\n    term.log(\n      '- constraints (' +\n        constraints.length +\n        ' -> ' +\n        propagators.length +\n        '):'\n    );\n    term.log(\n      constraints\n        .map((c, index) => {\n          if (c.param === undefined) {\n            return `${WITH_INDEX ? index : ''}: ${c.name}(${\n              c.varIndexes\n            })      --->  ${c.varIndexes\n              .map(index => domain__debug(domains[index]))\n              .join(',  ')}`;\n          }\n\n          if (c.name === 'reifier') {\n            return `${WITH_INDEX ? index : ''}: ${c.name}[${c.param}](${\n              c.varIndexes\n            })      --->  ${domain__debug(domains[c.varIndexes[0]])} ${\n              c.param\n            } ${domain__debug(domains[c.varIndexes[1]])} = ${domain__debug(\n              domains[c.varIndexes[2]]\n            )}`;\n          }\n\n          return `${WITH_INDEX ? index : ''}: ${c.name}(${c.varIndexes}) = ${\n            c.param\n          }      --->  ${c.varIndexes\n            .map(index => domain__debug(domains[index]))\n            .join(',  ')} -> ${domain__debug(domains[c.param])}`;\n        })\n        .join('\\n')\n    );\n    term.log('##/\\n');\n  }\n\n  _debugSolver() {\n    const term = getTerm();\n    term.log('## _debugSolver:\\n');\n\n    const { config } = this;\n    // Term.log('# Config:');\n    // term.log(INSPECT(_clone(config)));\n\n    const names = config.allVarNames;\n    term.log('# Variables (' + names.length + 'x):');\n    term.log('  index name domain toArr');\n    for (let varIndex = 0; varIndex < names.length; ++varIndex) {\n      term.log(\n        '  ',\n        varIndex,\n        ':',\n        names[varIndex],\n        ':',\n        domain__debug(config.initialDomains[varIndex])\n      );\n    }\n\n    const constraints = config.allConstraints;\n    term.log('# Constraints (' + constraints.length + 'x):');\n    term.log('  index name vars param');\n    for (let i = 0; i < constraints.length; ++i) {\n      term.log(\n        '  ',\n        i,\n        ':',\n        constraints[i].name,\n        ':',\n        constraints[i].varIndexes.join(','),\n        ':',\n        constraints[i].param\n      );\n    }\n\n    const propagators = config._propagators;\n    term.log('# Propagators (' + propagators.length + 'x):');\n    term.log('  index name vars args');\n    for (let i = 0; i < propagators.length; ++i) {\n      term.log(\n        '  ',\n        i,\n        ':',\n        propagators[i].name +\n          (propagators[i].name === 'reified'\n            ? '(' + propagators[i].arg3 + ')'\n            : ''),\n        ':',\n        propagators[i].index1,\n        propagators[i].index2,\n        propagators[i].index3,\n        '->',\n        domain__debug(config.initialDomains[propagators[i].index1]),\n        domain__debug(config.initialDomains[propagators[i].index2]),\n        domain__debug(config.initialDomains[propagators[i].index3])\n      );\n    }\n\n    term.log('##');\n  }\n\n  _debugConfig() {\n    const config = _clone(this.config);\n    config.initialDomains = config.initialDomains.map(domain__debug);\n\n    getTerm().log('## _debugConfig:\\n', INSPECT(config));\n  }\n\n  /**\n   * Import from a dsl into this solver\n   *\n   * @param {string} s\n   * @param {boolean} [_debug] Log out entire input with error token on fail?\n   * @returns {FDO} this\n   */\n  imp(s, _debug) {\n    // Term.log('##x## FDO.imp(...)');\n    // term.log(s);\n    // term.log('##y##');\n\n    if (this.logging) {\n      getTerm().log('      - FD Importing DSL; ' + s.length + ' bytes');\n      getTerm().time('      - FD Import Time:');\n    }\n\n    const solver = importer(s, this, _debug);\n    if (this.logging) {\n      getTerm().timeEnd('      - FD Import Time:');\n    }\n\n    return solver;\n  }\n\n  /**\n   * Export this config to a dsl. Optionally pass on a\n   * space whose vardoms state to use for initialization.\n   *\n   * @param {$space} [space]\n   * @param {boolean} [usePropagators]\n   * @param {boolean} [minimal]\n   * @param {boolean} [withDomainComments]\n   * @returns {string}\n   */\n  exp(space, usePropagators, minimal, withDomainComments) {\n    return exporter(\n      this.config,\n      space.vardoms,\n      usePropagators,\n      minimal,\n      withDomainComments\n    );\n  }\n\n  /**\n   * Exposes internal method domain_fromList for subclass\n   * (Used by PathSolver in a private project)\n   * It will always create an array, never a \"small domain\"\n   * (number that is bit-wise flags) because that should be\n   * kept an internal fdq artifact.\n   *\n   * @param {number[]} list\n   * @returns {$arrdom[]}\n   */\n  static domainFromList(list) {\n    return domain_fromListToArrdom(list);\n  }\n\n  /**\n   * Expose the internal terminal (console)\n   *\n   * @returns {Object} Unless overridden, this is the console global. Otherwise an object with al least the same methods as console\n   */\n  static getTerm() {\n    return getTerm();\n  }\n\n  /**\n   * Set the terminal object (console by default)\n   *\n   * @param {Object} term An object that overrides one or more methods on `console`\n   */\n  static setTerm(term) {\n    return setTerm(term);\n  }\n\n  static dsl() {\n    THROW('FDO.dsl: use FDO.solve()');\n  }\n\n  static imp() {\n    THROW('FDO.imp: use FDO.solve()');\n  }\n\n  /**\n   * Shorthand for processing a dsl and returning the first solution, or a string describing reason for failure.\n   *\n   * @param {string} dsl\n   * @param {Object} options Passed on to the FDO constructor\n   * @param {boolean} [_debug] Log out entire input with error token on fail?\n   * @returns {string|Object|Object[]|FDO} Will return all results if max explicitly not 1, returns FDO if options ask\n   */\n  static solve(dsl, options = {}, _debug) {\n    if (!options.max) options.max = 1;\n    const fdo = new FDO(options).imp(dsl, _debug);\n    const s = fdo.solve(options);\n    if (options.returnFdo) return fdo;\n    if (fdo.config.aborted) return 'aborted';\n    if (s.length === 0) return 'rejected';\n    if (options.max !== 1) return s;\n    return s[0];\n  }\n}\n\n/**\n * Deep clone given object for debugging purposes (only)\n * Revise if used for anything concrete\n *\n * @param {*} value\n * @returns {*}\n */\nfunction _clone(value) {\n  switch (typeof value) {\n    case 'object': {\n      if (!value) return null;\n      if (Array.isArray(value)) {\n        return value.map(v => _clone(v));\n      }\n\n      const obj = {};\n      for (const [key, val] of Object.entries(value)) {\n        obj[key] = _clone(val);\n      }\n\n      return obj;\n    }\n\n    case 'function': {\n      const fobj = {\n        __THIS_IS_A_FUNCTION: 1,\n        __source: value.toString(),\n      };\n      for (const [key, val] of Object.entries(value)) {\n        fobj[key] = _clone(val);\n      }\n\n      return fobj;\n    }\n\n    case 'string':\n    case 'number':\n    case 'boolean':\n    case 'undefined':\n      return value;\n\n    default:\n      THROW('config value what?', value);\n  }\n}\n\n/**\n * This is the core search loop. Supports multiple solves although you\n * probably only need one solution. Won't return more solutions than max.\n *\n * @param {Object} state\n * @param {$config} config\n * @param {number} max Stop after finding this many solutions\n * @param {Function} [dbgCallback] Call after each epoch until it returns false, then stop calling it.\n * @returns {$space[]} All solved spaces that were found (until max or end was reached)\n */\nfunction solver_runLoop(state, config, max, dbgCallback) {\n  const list = [];\n  while (state.more && list.length < max) {\n    search_depthFirst(state, config, dbgCallback);\n    if (state.status !== 'end') {\n      list.push(state.space);\n      ASSERT_LOG(LOG_FLAG_SOLUTIONS, log =>\n        log(' ## Found solution:', space_solution(state.space, config))\n      );\n    }\n  }\n\n  return list;\n}\n\nfunction solver_getSolutions(solvedSpaces, config, solutions, log) {\n  ASSERT(\n    Array.isArray(solutions),\n    'solutions target object should be an array'\n  );\n  if (log >= LOG_STATS) {\n    getTerm().time('      - FD Solution Construction Time');\n  }\n\n  for (let i = 0; i < solvedSpaces.length; ++i) {\n    const solution = space_solution(solvedSpaces[i], config);\n    solutions.push(solution);\n    if (log >= LOG_SOLVES) {\n      getTerm().log('      - FD solution() ::::::::::::::::::::::::::::');\n      getTerm().log(JSON.stringify(solution));\n      getTerm().log('                      ::::::::::::::::::::::::::::');\n    }\n  }\n\n  if (log >= LOG_STATS) {\n    getTerm().timeEnd('      - FD Solution Construction Time');\n  }\n}\n\nexport default FDO;\n"],"names":["constraint_create","name","varIndexes","param","_class","propagator_divStep","space","config","varIndex1","varIndex2","varIndex3","ASSERT","domain1","vardoms","domain2","domain3","_propagator_divStep","ASSERT_LOG","LOG_FLAG_PROPSTEPS","log","domain__debug","ASSERT_NORDOM","domResult","domain","domain_divby","domain_intersection","markov_getNextRowToSolve","matrix","row","i","length","boolDomain","_boolVarIndex","undefined","domain_getValue","markov_createLegend","merge","inputLegend","markov_mergeDomainAndLegend","legend","slice","listed","domain_toList","val","indexOf","push","markov_createProbVector","expandVectorsWith","valueCount","probVector","vector","delta","THROW","propagator_markovStepBare","varIndex","domain_isSolved","value","domain_min","configVarDistOptions","varDistOptions","distributeOptions","allVarNames","JSON","stringify","valtype","values","probabilities","pos","domain_createEmpty","propagator_minStep","nR","_propagator_minStep","domain_isEmpty","domain_minus","TRACE","propagator_mulStep","_propagator_mulStep","domain_mul","propagator_reifiedStepBare","leftVarIndex","rightVarIndex","resultVarIndex","opFunc","nopFunc","opName","invOpName","opRejectChecker","nopRejectChecker","domain_isZero","domain_hasNoZero","domain_removeValue","domain_removeGtUnsafe","propagator_ringStepBare","domain_plus","domain_invMul","_propagator_ringStepBare","u","n","l","v","domainResult","propagator_ltStepBare","lo1","hi2","domain_max","domain_removeGte","domain_removeLte","propagator_gtStepBare","propagator_ltStepWouldReject","result","propagator_gtStepWouldReject","propagator_lteStepBare","propagator_gteStepBare","propagator_lteStepWouldReject","propagator_gteStepWouldReject","propagator_eqStepBare","propagator_eqStepWouldReject","domain_sharesNoElements","propagator_neqStepBare","NO_SUCH_VALUE","propagator_neqStepWouldReject","propagator_create","stepper","index1","index2","index3","arg1","arg2","arg3","arg4","arg5","arg6","propagator_addReified","opname","nopName","config_addPropagator","propagator_addEq","propagator_addLt","propagator_addGt","propagator_addLte","propagator_addMul","propagator_addDiv","propagator_addGte","propagator_addNeq","propagator_addDistinct","j","propagator_addRingPlusOrMul","targetOpName","propagator_addRing","A","B","C","propagator_addPlus","propagator_addMin","propagator_addRingMul","propagator_addSum","Array","isArray","len","t1","Math","floor","config_addVarAnonNothing","t2","propagator_addProduct","propagator_addMarkov","config_create","_varNamesTrie","trie_create","varStratConfig","config_createVarStratConfig","valueStratName","targetedVars","beforeSpace","afterSpace","rngCode","_defaultRng","allConstraints","constantCache","initialDomains","_propagators","_varToPropagators","_constrainedAway","_constraintHash","process","env","NODE_ENV","_propagates","config_clone","newDomains","clone","parse","map","domain_toSmallest","config_addVarNothing","varName","_config_addVar","domain_createRange","SUB","SUP","config_addVarAnonRange","lo","hi","config_addVarAnonConstant","config_addVarRange","config_addVarDomain","_allowEmpty","_override","domain_anyToSmallest","config_addVarConstant","trie_has","index","trie_get","String","parseInt","solvedTo","NOT_FOUND","trie_add","obj","type","priorityByName","_priorityByIndex","inverted","Boolean","fallback","config_setOption","optionName","optionValue","optionTarget","dist_name","vsc","rvsc","Object","entries","key","boolean","booleanId","boolFuncOrName","boolVarName","propagator","config_populateVarPropHash","hash","propagators","propagatorIndex","plen","_config_addVarConditionally","config_addConstraint","varNames","every","e","inputConstraintKeyOp","resultVarName","anonIsBool","sumOrProduct","config_compileConstants","config_dedupeConstraint","join","config_varNamesToIndexes","constraint","TRIE_KEY_NOT_FOUND","constraintUI","haveConstraint","Error","config_generatePropagators","getTerm","warn","p","INSPECT","config_generatePropagator","_constraint","config_generateMarkovs","keys","options","config_populateVarStrategyListHash","list","config_init","Function","random","ASSERT_VARDOMS_SLOW","exporter","usePropagators","minimal","withDomainComments","realName","var_dist_options","domains","indexToString","exporter_encodeVarName","exporter_varstrShort","exporter_varstrNum","vars","exporter_domstr","s","overrides","replace","constraints","indexes","aliases","forEach","paramName","paramV","comment","op","t","alias","max","filter","v1","name1","v2","name2","v3","name3","repeat","toString","arrdom","domain_toArr","dom","importer","str","solver","_debug","FDO","pointer","isEof","parseStatement","read","readD","skip","is","c","desc","skipWhitespaces","isWhitespace","skipWhites","isWhite","isComment","skipComment","isNewline","expectEol","atEol","parseVar","parseAtRule","parseUndefConstraint","nameNames","parseIdentifier","parseDomain","mod","parseModifier","decl","parseQuotedIdentifier","parseUnquotedIdentifier","start","isValidUnquotedIdentChar","parseNumber","stratName","parseList","parseMarkov","parseNumList","code","func","parseUexpr","parseVexpr","cop","parseCop","parseAssignment","eq","neq","lt","lte","gt","gte","mul","num","plus","isEq","isNeq","freshVar","hasVar","parseAssignRest","rop","parseRop","isLt","isLte","isGt","isGte","compileIssome","compileIsnone","compileIsall","compileIsnall","minus","div","a","b","parseAll","parseDistinct","parseNall","parseNone","parseSame","parseSome","parseXnor","parseVexpList","resultVar","parseGrouping","d","ident","parseSum","parseProduct","parseIsAll","parseIsDiff","parseIsNall","parseIsNone","parseIsSame","parseIsSome","refs","r","product","vals","distinct","sum","args","x","reifs","indexA","indexB","y","parseNumstr","nums","numstr","parseIdentList","idents","readLine","line","parseVarStrat","parseValStrat","target","parseRestCustom","setValueDistributionFor","parseTargets","msg","min","space_uid","space_createRoot","_depth","_child","_path","space_createNew","space_createFromConfig","space_initFromConfig","space_createClone","vardomsCopy","unsolvedVarIndexes","_unsolved","_child_count","space_toConfig","domain_toStr","next_distribution_choice","updatedVarIndex","_lastChosenValue","_uid","space_generateVars","space_initializeUnsolvedVars","targetVarNames","varNamesTrie","space_addVarNameToUnsolved","space_propagate","space_onBeforePropagate","cells","ceil","TRIE_NODE_SIZE","changedTrie","TRIE_EMPTY","cycles","changedVars","rejected","space_propagateAll","newChangedVars","space_propagateChanges","space_onAfterPropagate","cycleIndex","space_propagateStep","space_propagateByIndexes","propagatorIndexes","space_recordChange","status","trie_getNum","trie_addNum","allPropagators","targetVars","varToPropagators","vlen","callback","aborted","space_updateUnsolvedVarList","m","space_solution","space_getVarSolveState","BETTER","SAME","WORSE","distribution_getNextVarIndex","isBetterVarFunc","distribution_getFunc","_distribution_varFindBest","distName","distribution_varByMinSize","distribution_varByMin","distribution_varByMax","distribution_varByMarkov","distribution_varByList","fitnessFunc","bestVarIndex","domain_size","distOptions","varName1","varName2","distribution_varFallback","p1","p2","fallbackConfig","distribution_markovSampleNextFromDomain","valLegend","randomFunc","rngIsNormalized","filteredLegend","cumulativeFilteredProbVector","totalProb","prob","domain_containsValue","_distribution_markovRoll","rng","cumulativeProbVector","valueLegend","rngRoll","probVal","probVectorCount","FIRST_CHOICE","SECOND_CHOICE","THIRD_CHOICE","NO_CHOICE","distribute_getNextDomainForVar","choiceIndex","valueStrategy","valueDistributorName","_distribute_getNextDomainForVar","LOG_FLAG_CHOICE","distribution_valueByMax","distribution_valueByMarkov","distribution_valueByMid","distribution_valueByMin","distribution_valueByMinMaxCycle","distribution_valueByList","distribution_valueBySplitMax","distribution_valueBySplitMin","listSource","fallbackName","nextValue","domain_getFirstIntersectingValue","domain_createValue","minValue","maxValue","middle","domain_middleElement","mmhalf","_isEven","lastValue","newDomain","search_depthFirst","state","dbgCallback","stack","epochs","isStart","solved","search_depthFirstLoop","LOG_FLAG_SEARCH","childSpace","search_createNextSpace","pop","more","search_afterPropagation","failed","_search_onSolve","choice","nextDomain","logger","setTerm","logging","LOG_NONE","distribute","exportBare","GENERATE_BARE_DSL","exported","solutions","_prepared","isNaN","domainOrValue","distributionOptions","ASSERT_ARRDOM","decls","declRange","R","e1","e2","solve","_prepare","_tostring","_debugConfig","_debugSpace","_debugSolver","epoch","_debugDelay","_debugLegible","_space","_nosolve","_run","LOG_MIN","LOG_MAX","LOG_STATS","time","_prepareConfig","rootSpace","timeEnd","term","alreadyRejected","solvedSpaces","solver_runLoop","solver_getSolutions","RegExp","branch_from_current_solution","solvedConfig","names","targeted","WITH_INDEX","_clone","imp","exp","domainFromList","domain_fromListToArrdom","dsl","fdo","returnFdo","fobj","__THIS_IS_A_FUNCTION","__source","LOG_FLAG_SOLUTIONS","solution","LOG_SOLVES"],"mappings":"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"}